### JS进阶
#### 事件对象
##### 1.1 事件对象是什么
我们可以把事件的处理函数，当做一个回调函数。`click`事件发生的时候，才调用这个`function(){}`
```javascript
oDiv.onclick = function(){
}
```
`浏览器在调用这个事件处理函数，调用的时候还传进去一个实际参数`，这个参数是一个对象，表示这次点击事件的所有细节。比如按的什么按钮、点击的位置等等。
所以，我们的事件处理函数，就要通过一个形式参数来接收。
```javascript
oDiv.onclick = function(event){

}
```
比如，获得鼠标当前的位置：
```javascript
document.onmousemove = function(event){
	h1.innerHTML = "当前鼠标坐标为" + event.clientX + "," + event.clientY;
}
```
event.clientX表示触发事件的时候，鼠标的x位置（相对于视口）
不同的事件，就有不同的event值。可以想象到键盘事件，没有鼠标的位置。而是有event.keyCode按下去的键盘码的值。
##### 1.2 IE6、7、8的兼容问题
- 超级兼容大坑：在调用事件处理函数的时候，高级浏览器是传给这个事件处理函数一个实际参数event对象。但是IE6、7、8是给window对象绑定一个当前的event属性。
IE中：
```javascript
document.onmousemove  = function(){
	h1.innerHTML = "当前鼠标坐标为" + window.event.clientX + "," + window.event.clientY;
}
```
所以现在就有一个兼容性的处理的小窍门：
```javascript
//在页面上鼠标移动的时候，触发事件
document.onmousemove  = function(event){
	event = event || window.event;
	h1.innerHTML = "当前鼠标坐标为" + event.clientX + "," + event.clientY;
}
```
|| 就是或逻辑短路运算符，如果event有定义，那么就event对象；否则就是window.event对象。
IE中有很多方法的名字和高级浏览器不一样，比如昨天说的阻止默认事件：
```javascript
event.preventDefault();
```
在IE中是一个属性：
```javascript
event.returnValue = false;
```
这些的兼容性问题，就用能力检测来解决：
```javascript
//阻止默认的滚动事件，阻止的方法有浏览器兼容问题：
if(event.preventDefault){
	event.preventDefault();
}else{
	event.returnValue = false;
}
```
包括preventDefault()方法在IE6、7、8中不支持在内，我们要记住这三个：
```javascript
event.preventDefault()不兼容！ 在IE6、7、8中用event.returnValue=false; 代替
event.stopPropagation()不兼容！在IE6、7、8中用event.cancelBubble=true; 代替 
event.target不兼容，在IE6、7、8中用event.srcElement代替
```
event.target兼容解决，就是用一个短路语法
```javascript
var targetElem = event.target || event.srcElement;
```
#### 各种值
##### 2.1 鼠标位置event.clientX、event.screenX
下面4个值是全线兼容的：
```javascript
1event.clientX
2event.clientY
3event.screenX
event.screenY
```
这四个值都没有单位。
clientX表示鼠标距离视口左边x值
screenX表示鼠标距离整个屏幕左边x值
#### 滚轮事件
滚轮就是鼠标上的滚轮，它滚动的时候触发事件。
注意，window.onscroll这是窗口的卷动事件，不管因为什么（滚轮、滚动条、键盘上下键）导致页面卷动了，就会触发window.onscroll事件。
滚轮事件就是鼠标滚动的时候触发，不一定引起页面的卷动。
```javascript
1oDiv.onmousewheel = function(event){
2	oDiv.innerHTML = event.wheelDelta;
}
```
onmousewheel就是鼠标滚动事件，mouse鼠标，wheel就是轮子。
event参数最最重要的事就event.wheelDelta属性，表示滚动的方向。这是浏览器的规定：
如果滚动快速，可能出现120的整数倍，正负性是一样的。
onmousewheel事件的触发，是滚轮滚动一“咯噔”触发一次。
#### 滚屏原理
我们现在用原生JS讲解原理，页面上动画、尤其是动画序列、delay进场用jQuery来做更合适。

火车法：
HTML布局：
```html
1<div class="contanier">
2		<div class="page page0"><h1>0</h1></div>
3		<div class="page page1"><h1>1</h1></div>
4		<div class="page page2"><h1>2</h1></div>
5		<div class="page page3"><h1>3</h1></div>
6		<div class="page page4"><h1>4</h1></div>
	</div>
```
CSS从小到大都是height:100%; 撑高为浏览器屏幕高度
```css
html,body{
		width: 100%;
		height: 100%;
		overflow: hidden;
	}
	.contanier{
		width: 100%;
    	height: 100%;
		position: absolute;
		top: -300%;
		left: 0;
	}
	.page{
		width: 100%;
		height: 100%;
		background: yellowgreen;
		}
```
#### object类型
##### 1.1 对象的创建
创建一个对象，有两种方法，第一种比较简单，叫做字面量；第二种是用new Object()。
1.1.1 字面量的创建方式
````javascript
var obj = {
      name : "考拉",
      age : 18,
      sex : "男"
    };
	console.log(obj);
	console.log(obj.name);
	console.log(typeof obj);
````
{}就是对象的界定符，就是对象的字面量。对象有属性，所谓的属性就是这个对象的特点、特性，name、age、sex都是这个obj对象的属性（preperty）。
哲学上讲，什么是对象？对象就是属性的无序集合。
我们可以用.点语法、方括号法来获得一个对象的属性。那么你会发现，和数组有点相似，只不过数组的下标只能是数字0、1、2……，而我们的对象，可以用任何的词儿来当做属性名。

公式：
```javascript
{
	k : v,
	k : v,
	k : v,
	k : v
}
```
JSON和对象字面量的区别：
之前学习过JSON，JSON要求所有的k必须加引号，而对象字面量不需要加引号，当然加引号也不错。
JSON = JavaScript Object Notation，JS对象表示法。JSON是一个用于交换的格式，所以JSON不仅仅JavaScript用，后台语言比如PHP、Java、ASP等等都要识别JSON，为了最大的兼容，k必须加引号。也就是说，JSON里面的k加引号，不是因为JS，而是因为后台的那些语言。
JSON要比对象字面量，要严格，严格在哪儿呢？就是所有的k，必须加引号。
JSON：
```json
{
	"k" : v,
	"k" : v,
	"k" : v,
	"k" : v
} 
```
但是，下面的特殊情况，这个k必须加引号：
k是特殊字符
k是数字
k是有空格
k是关键字、保留字
先说一下，上面这些情况，也同时不能使用点语法来访问属性了，比如使用方括号：
```javascript
var obj = {
	name : "考拉"
};
console.log(obj["name"]);
```
特殊形式的k，必须要加上引号，检索属性的时候，必须用方括号：
```javascript
var obj = {
"24&*$&#@@)@!" : "哈哈",
"all name" : "考拉",
"++++%%%%" : "嘻嘻",
"var" : "么么哒",
"function" : "嘻嘻"
} 
	console.log(obj["24&*$&#@@)@!"]);
	console.log(obj["all name"]);
	console.log(obj["++++%%%%"]);
	console.log(obj["var"]);
	console.log(obj["function"]);
```
你会发现，JS会一个对象的属性名，没有特殊的规定。这是因为属性名不是标识符，没有那些规定。
对象的属性的访问，点语法是有局限的，它不能访问上面的特殊的那些情况。也不能访问以变量保存的k：
```javascript
var obj = {
		name : "考拉",
		age : 18,
		sex : "男",
		"study score" : 100
	}

	//console.log(obj."study score");//错误的
	console.log(obj["study score"]);	//正确的
	console.log(obj["a" + "ge"]);		//正确的
	var a = "sex";
	console.log(obj[a]);			//正确的
```
1.1.2 new Object()创建对象
```javascript
var obj = new Object();	//这是一个空对象，里面没有任何属性
obj.name = "考拉";
obj.age = 18;
obj.sex = "男";
console.log(obj);	
console.log(obj.age);	
console.log(typeof obj);
```
new是一个运算符，你没有看错，和+-*/一样是一个运算符。表示新创建一个对象。一会儿我们学习构造函数，实际上你将了解到new是一个函数调用的方式。Object()大写字母O，这是一个系统内置的构造函数，什么是构造函数，我们稍后讲到。
下面就可以用obj.k = v ;来追加属性了
```javascript
obj.name = "考拉";
```
这是一条语句，如同：
```javascript
oDiv.className = "current";
```
事实上，工程师更喜欢用字面量的方式来创建对象。因为更直观：
字面量方式：
```javascript
var obj = {
	name : "考拉",
	age : 18,
	sex : "男"
};
```
构造函数方式：
```javascript
var obj = new Object();
obj.name = "考拉";
obj.age = 18;
obj.sex = "男";
```
上面两种方式创建出来的对象，是相同的。字面量的方式直观、简单、并且有“封装”的感觉。所以我们鼓励大家用字面量来创建对象。
但是，不要杂糅：
```javascript
var obj = {};   //的确能创建一个空对象
obj.name = "考拉";   //追加属性
obj.age = 18;        //追加属性
obj.sex = "男";      //追加属性
```
##### 1.2 对象的属性值
对象属性值，可以是任何东西。比如数字、字符串、布尔值、正则表达式、对象、数组、函数……
```javascript
var kaola = {
		name : "考拉",
		age : 18,
		peiou : {
			name : "母考拉",
			age : 19
		}
	}

		console.log(kaola.peiou.age);
```
```javascript
var obj = {
		a : 1,
		b : "哈哈",
		c : true,
		d : /[A-Z]/g,
		e : function(){
			alert(1+2);
		},
		f : {
			p : 1
		}
		}
```
特别的，当对象的属性的值是一个函数的时候，我们称这个函数是对象的方法。
#### 二、对象的方法
当一个对象的属性的值，是一个函数，那么这个函数我们就称为对象的“方法”(method)。
方法就是一个对象能够做的事情，一般来说，就是一个动词。比如小明打招呼、长大、变性方法。
```javascript
var xiaoming = {
		name : "小明",
		age : 18,
		sex : "男",
		sayHello : function(){
			alert("你好，我是" + this.name);
			alert("今年" + this.age + "岁了");
			alert("我是可爱的小" + this.sex + "生");
			}
	}
	xiaoming.sayHello();
```
比如上面的案例，sayHello就是一个属性，只不过它的值是一个函数，所以我们就可以说xiaoming这个对象，有sayHello方法。
一个对象，方法函数里面的this指的是这个对象。

那我们复习一下现在，我们调用函数的方式有哪些？这些调用函数的方式，里面的this又是谁？
直接用()运算符来调用函数，那么函数里面的this指的是window对象
● 函数如果绑定给了某个HTML元素的事件上，那么函数里面的this就是这个HTML对象
● 用定时器调用函数，函数内部的this就是window对象
● 用对象打点（方法）来调用函数，函数里面的this指的是这个对象
● 用apply、call，可以人工设置this是谁了，百变。
说白了，我们学习“方法”，无非就是学习了一种函数的调用方式。这个函数里面的this指的是这个对象。
函数里面的this到底是谁，在函数定义的时候并不知道，要看函数如何被调用。

对象的方法的哲学，就是操作自己的属性。如果一个对象的方法，不操作自己的属性，那干嘛还要是方法呢？
zhangda方法，就是让自己的age++：
```javascript
var xiaoming = {
  name : "小明",
  age : 18,
  sex : "男",
  sayHello : function(){
  alert("你好，我是" + this.name);
  alert("今年" + this.age + "岁了");
  alert("我是可爱的小" + this.sex + "生");
  },
  zhangda : function(){
	this.age++;
  }
}
```
#### 构造函数
JavaScript规定，一个函数可以用new关键字来调用。那么此时将按顺序发生四件事情：
1）隐秘的创建一个新的空对象
2）将这个函数里面的this绑定到刚才创建隐秘新对象上
3）执行函数体里面的语句
4）返回这个新的对象
```javascript
function People(){
  this.name = "小明";
  this.age = 18;
  this.sex = "男";	
}
var xiaoming = new People();

console.log(xiaoming);
console.log(xiaoming.age);
console.log(typeof xiaoming);
```
上面的函数的机理：
好了，也就是说，我们现在学习了函数的新的调用方式：使用new关键字来调用。
此时很有意思，函数不仅仅能够执行，还能返回出来一个对象。也就是说，对象是函数“生”出来的，对象是函数“new”出来的。
我们称呼这个函数，叫做构造函数，一般的，构造函数用大写字母开头。也叫作People“类”。
我们称呼xiaoming这个对象是People类的实例。
#### 原型prototype
##### 4.1 原型的定义
我们先来看一个事儿：
```javascript
function fun(){
			alert("你好");
		}
	console.log(fun.prototype); //=>Objec{}
console.log(typeof fun.prototype); //=> object
```
在JavaScript中，任何一个函数，都有一个prototype属性，指向一个对象。我们输出了一个函数的prototype属性，你会发现是一个空对象。输出这个prototype的类型，发现是object类型。
prototype就是英语“原型”的意思。每个函数都有原型，原型是一个对象。
一个函数的原型，对于普通函数来说，没任何鸟用。但是如果函数是一个构造函数，那么函数的原型，用处极大！
```javascript
//构造函数，构造函数里面没有任何语句，也就是说，这个构造函数在执行的时候，不会给创建出来的对象添加任何属性。
function People(){

}
//构造函数的原型，我们更改了构造函数的原型，为一个新的对象：
People.prototype = {
	name : "考拉",
	sex : "男",
	age : 18
}

//当一个对象被new出来的时候，不仅仅执行了构造函数里面的语句，也会把这个函数的__proto__指向构造函数的prototype。
var xiaoming = new People();

console.log(xiaoming.__proto__);
console.log(xiaoming.__proto__ == People.prototype);

//当我们试图访问name、sex、age属性的时候，身上没有。那么就去查找原型，原型身上有，就当做了自己的属性返回了。
console.log(xiaoming.name);
console.log(xiaoming.sex);
console.log(xiaoming.age);
```
prototype一定是函数的属性！当这个函数是一个构造函数的时候，那么它new出来的对象，将以它的原型那个对象为new出来的实例的原型对象。
注意，任何一个对象，都有__proto__属性，这个属性是Chrome自己的属性，别的浏览器不兼容，但是别的浏览器也有原型对象，只不过不能通过__proto__进行访问而已。
这是属性指向自己的原型对象。

我们的JavaScript有一个非常牛逼的机制：原型链查找。
当我们试图访问一个对象身上的属性的时候，如果这个对象身上有这个属性，则返回它的值。如果它身上没有这个属性，那么将访问它的原型对象，检测它的原型对象身上是否有这个值，如果有返回它原型对象身上的这个值。

也就是说，我们刚才讲解了2个对象和一个函数的故事。任何一个函数都有原型，原型是一个对象，用prototype来访问。当这个函数是构造函数的时候，new出来的对象，它们的原型对象就是这个构造函数的原型。
prototype我们称为“原型”，只有函数有原型
__proto__我们称为“原型对象”，任何对象都有原型对象。
##### 4.2 原型的用途
我们定义一个方法的时候，如果写在构造函数里面：
```javascript
function People(name,age){
			this.name = name;
		this.age = age;
		this.sayHello = function(){
			alert("你好,我是" + this.name + "我今年" + this.age + "岁了");
		}
	}

	var xiaoming = new People("小明",12);
	var xiaohong = new People("小红",11);

	xiaoming.sayHello();
	xiaohong.sayHello();
```
实际上这个函数被复制了两
````javascript
alert(xiaoming.sayHello == xiaohong.sayHello); //false
````
xiaoming身上的函数，和xiaohong身上的函数，不是同一个函数。
那应该怎么办呢？一句话：所有的属性要绑在对象身上，而所有的方法，定义在对象的原型对象中：
```javascript
function People(name,age){
//构造函数里面，负责定义一些属性，随着构造函数的执行，这些属性将绑定到new出来的对象身上
	this.name = name;
	this.age = age;
}
//把所有的方法，定义在原型对象身上：
People.prototype.sayHello = function(){
	alert("你好,我是" + this.name + "我今年" + this.age + "岁了");
}
```
```javascript
alert(xiaoming.sayHello == xiaohong.sayHello); //true
```
证明了xiaoming的sayHello方法和xiaohong的，是同一个函数。内存消耗小很多。
##### 4.3 JavaScript原型链机制
先学一个属性，constructor，函数的原生有constructor属性，指向构造函数。
```javascript
People.prototype.constructor //指向构造函数
```
我们之前说过，一个对象的原型身上有什么，那么实例对象就也可以打点调用什么，所以：
```javascript
xiaoming.constructor   //指向构造函数
```
只要是对象，一定有原型对象，就是说只要这个东西是个对象，那么一定有__proto__属性。
世界上只有一个对象没有原型对象，这个对象就是Object.prototype。

Object是一个函数，是系统内置的构造函数，用于创造对象的。Object.prototype是所有对象的原型链终点。
所以，当我们在一个对象上打点调用某个方法的时候，系统会沿着原型链去寻找它的定义，一直找到Object.prototype。

所有的引用类型值，都有内置构造函数。比如
new Object()
new Array()
new Function()
new RegExp()
new Date()

我们来看看数组的情况：

函数也是对象。JavaScript中函数是一等公民，函数是对象。函数也是对象，只不过自己能()执行。

基本类型值，也有包装类型。所谓包装类型，就是它的构造函数。
new Number()
new String()
new Boolean()

所以你就能明白，为毛毛”abc”能够调用indexOf()方法，是因为String.prototype身上有这个方法。

更多的理论：继承、in操作符、hasOwnPreperty、delete明天讲。理论和实际结合起来。
#### 五、面向对象的思维方式
实际上，在JS中面向对象技术，已经变为了组织代码的方式。
比如页面上有一个轮播图，就一个，我们用jQuery嗷嗷写就行了。但是页面上有三个轮播图，代码维护、共用的困难。所以就用面向对象来组织代码，这就是组件开发。
为了让大家体会面向对象的好处，或者说必须用面向对象的思路来解决问题，我们用游戏来引导你。
#### 继承

“人”类 ， “小学生”类。 小学生也是人，只不过“丰富了”人。
“人”类有的属性，“小学生”都有，比如姓名、年龄、性别。
“人”类有的方法，“小学生”都有，比如打招呼、吃饭、睡觉。
除此之外，
“小学生”还丰富了一些属性：学号、班级、小红花个数、是否少先队员
“小学生”还丰富了一些方法：学习、lol、上课

小学生类，继承了人类。一说继承，千万不要想到人生的遗产继承，感觉小学生比人类少，是人类的局部。千万不要这么想。在计算机世界中，继承是“丰富”，是比原来的类要多东西。
小学生继承于人类， 小学生更丰富。

说白了，People、Student两个类，Student类的实例，拥有 People的全部属性属性、方法。
现在，你就应该朦朦胧胧的感觉到，用原型链来实现。JavaScript中没有extends。
People叫做父类、超类； Student叫做子类。

JS中实现继承的口号：

子类的prototype等于父亲的某个实例


来看一个具体案例：
```javascript
 function People(name,age,sex){
			this.name = name;
			this.age = age;
		this.sex = sex;
		}
	People.prototype.sayHello = function(){
			alert("你好我是人" + this.name);
		}
	People.prototype.chifan = function(){
		alert("我吃饭了！mia mia");
		}


		function Student(name,age,sex,xuehao,xiaohonghuageshu){
			this.name = name;
		this.age = age;
		this.sex = sex;
			this.xuehao = xuehao;
		this.xiaohonghuageshu = xiaohonghuageshu;
		}
		//核心语句，继承的实现全靠这条语句了：
		Student.prototype = new People();
		
		Student.prototype.sayHello = function(){
			alert("你好我是小学生，我的学号是" + this.xuehao);
		}
		Student.prototype.study = function(){
			alert("好好学习，天天向上");
		}
		Student.prototype.lol = function(){
			alert("玩儿英雄联盟啊！");
		}

		var xiaohong = new Student("小红",11,"女",20160001,4);
		//xiaohong.lol();
		//xiaohong.chifan();
		xiaohong.sayHello();
```
子类可以覆盖父类的一些方法，父类的方法不冲突，因为我们子类追加的方法，追加到了父类的实例上。
这种方法不行：追加子类方法的时候，父类也被改了：
#### 三、对象与属性
##### 3.1 in运算符
返回一个布尔值，表示这个属性是不是对象的属性。
```javascript
var obj = {
			a : 1,
			b : 2,
			c : false
		}

		console.log("a" in obj);	//true
		console.log("b" in obj);	//true
		console.log("c" in obj);	//true
		console.log("d" in obj);	//false
```
in不仅仅检测是对象自己有没有这个属性，如果原型链上有这个属性，那么也会返回true。整个原型链如果没有这个属性，就返回false。也就是说，in操作符会进行原型链查找。
for in 这个循环，会把原型链上所有的可枚举的属性列出来：
```javascript
for(var k in obj){
	console.log(k);
}
```
什么是可枚举，系统默认的属性（比如constructor）都是不可枚举的。for in循环能够把自己添加的属性罗列出来，罗列的不仅仅是自己身上的属性，还有原型链上的所有属性。
##### 3.2 hasOwnProperty方法
这个方法定义在了Object.prototype对象上面，所以任何一个Object都能够拥有这个方法。
这个方法返回true、false。表示自己是否拥有这个属性，不考虑原型链。就看自己身上有没有这个属性，不进行原型链查找
```javascript
var obj = {
			a : 1,
			b : 2,
			c : 3
		}
		obj.__proto__ = {
			d : 4
		}

		console.log(obj.hasOwnProperty("a")); //t
		console.log(obj.hasOwnProperty("b")); //t
		console.log(obj.hasOwnProperty("c")); //t
		console.log(obj.hasOwnProperty("d")); //f
```
for……in考虑原型链，所以我们可以内嵌一个判断，把自己身上的属性输出：
```javascript
for(var k in obj){
	obj.hasOwnProperty(k) && console.log(k);
}
```
##### 3.3 对象直接打点验证某个属性是否存在
对象打点调用属性，我们之前的课程已经讲过，遍历原型链。所以就可以看出来属性是否在自己身上、原型链上。如果在，就返回值；如果不在就返回undefined.
```javascript
var obj = {
			a : 1,
			b : 2,
			c : 3
		}
		obj.__proto__ = {
			d : 4
		}
		console.log(obj.m);	//undefined
 		console.log(obj.a);	//1
		console.log(obj.b);	//2
 		console.log(obj.c);	//3
 		console.log(obj.d);	//4
```
有个误会，比如obj.m值就是undefined，那么obj.m还是返回undefined。不知道m属性存在不存在。
#### 四、instanceof运算符
类在英语里面叫做class，实例在英语里面叫做instance。
instaceof运算符：
```javascript
A instaceof B//验证A对象是不是B类的实例。
```
比如：
```javascript
//类，构造函数
		function Dog(){

		}
		//实例化一个对象
		var d = new Dog();
		//验证d是不是Dog的一个实例
		console.log(d instanceof Dog);//true
```
这里要注意一个事儿：“HelloKitty是狗”：
```javascript
//类，构造函数
		function Dog(){

		}
	
		function Cat(){

		}
		Cat.prototype = new Dog();	//继承
		var hellokitty = new Cat();	//通过cat来实例一个
		console.log(hellokitty.constructor); //Dog
		console.log(hellokitty instanceof Cat); //true
		console.log(hellokitty instanceof Dog); //true
```
instanceof 运算符的机理： 遍访hellokitty这个对象的原型链上的每个原型对象，如果遍访到这个原型对象，是某个构造函数的prototype，那么就认为hellokitty是这个构造函数的实例，返回true。

一个数组用typeof检测的时候，返回object
```javascript
var arr = [];
console.log(typeof arr);//object
```
正则表达式也是：
```javascript
var obj2 = /ABC/g;
console.log(typeof obj2);
```
用instanceof运算符能够轻松解决数组的识别：
```javascript
var arr = [];
console.log(arr instanceof Array);//true
```
ECMAScript5标准中新增了一个API验证数组：
```javascript
Array.isArray(arr)//true 
//IE9开始兼容。
```
总结一下，A instanceof B， 不能证明A是new B()出来的，因为可能是继承。
#### JavaScript代码的组织
JS代码放到哪里？
##### 1.1 外链JS文件
外链JavaScript是一个组织JS的非常好的方法。
```html
<script type="text/javascript" src="js/1.js"></script>
<script type="text/javascript" src="js/2.js"></script>
```
JS的执行顺序，就是引包顺序的先后顺序。`包不能隔开作用域的`：
a能够正常输出100。JS文件（JS包)是不能隔开作用域的。在JavaScript中，唯一能够隔开作用域的就是function。

JS包里面定义的变量、函数，将在HTML外部失去变量声明的提升、函数声明头的提升。 
本质上，写在不同的<script></script>标签对儿里面的变量、函数，就已经失去变量声明的提升、函数声明头的提升。
正因为如此，我们必须：
```html
<script type="text/javascript" src="1.js"></script>   → 这个包里面定义了函数fun
<script type="text/javascript">
fun();   //→ 执行fun的时候，浏览器已经认识了fun
</script>
```
##### 1.2 页面中的JS与HTML
页面上会出现很多很多的特效，那么此时JS的摆放的位置，应该放到HTML结构的后面，并且习惯上紧跟HTML结构。这样做的好处是，我们就知道每个JavaScript的含义了，就知道这个JavaScript是负责上面HTML特效的。
##### 1.3 window.onload
延迟加载，当页面中的所有元素加载完毕之后，触发这个事件。你要注意，什么叫所有元素加载完毕呢？页面上的img图片，都是一点一点通过HTTP传输过来，当所有的img都传输完毕之后，才触发window.onload事件。
所以，之前讲过chrome有个小问题，就是一个盒子如果是用img撑宽的，那么oDiv.clientWidth就是0。这是因为读取这个盒子的宽度的时候，这个img还没有加载完毕。解决方法就是写在window.onload里面：
```javascript
window.onload = function(){
	var box = document.getElementsByTagName("div")[0];
	alert(box.clientWidth);
}
```
之前说过，DOM0级添加的事件，不能出现同名的。
```javascript
oDiv.onclick = function(){}
oDiv.onclick = function(){}
```
以后出现的为准，所以页面上只能有一个window.onload。
但是，如果使用DOM2级，
```javascript
window.addEventListener(”load”,function(){},false);
window.addEventListener(”load”,function(){},false);
```
就能够添加多个window.onload事件的处理函数。依次执行（attachEvent里面是反着的）。
jQuery中对应的事件叫做：
```javascript
$(document).ready(function(){

});
```
jQuery中的所有事件，都是通过DOM2级的机制添加的，所以jQuery中所有的事件，都能够同名。下午再说。

window.onload在工作中是不允许使用的。因为这个会把JS提前，与自己的HTML结构分开了，所以还是应该一个结构、一个JS文件；一个结构、一个JS文件这么写。
但是，window.onload在应对几个东西的时候，有非常大的作用：
1） 表单验证
2） onscroll事件
3） ……
所有的刚性的、事关穿不穿帮、事关安全的，都要写在window.onload里面。
我们先学习一下表单事件，onsubmit事件表示表单试图提交的那个瞬间。这个事件只能加给form对象。当标签里面的submit按钮点击的时候，触发。
```javascript
//当表单提交的时候
form.onsubmit = function(){
	alert("哈哈啊，你要提交表单啦？我不让你提交");
	return false;   //onsubmit事件里面，如果写了return false就不能提交表单了
}
```
表单提交非常的“刚性”，事关网站的安全，所以一定一定要写在window.onload里面，不要单独写js文件，不要写在HTML结构后面。让浏览器第一时间知道form有一个onsubmit事件。
```javascript
window.onload = function(){
			var box = document.getElementsByTagName("div")[0];
			// 浏览器必须在第一时间知道，这个页面滚动条滚动，是有事件的。
			window.onmousewheel = function(event){
				event.preventDefault();
			}
		}
```
#### 二、外链JS文件策略
上午说了，一个js文件不是一个作用域，但是我们仍然希望一个js文件就是独立的作用域。所以，就需要把语句写在function里面。
没有任何的理由，将js文件里面的语句散着写，因为散着写作用域被污染的严重，多个效果会冲突。
必须把js里面的所有语句放到函数里面，有三种方法：
#### 2.1 js文件中IIFE，HTML不需要调用
把js文件中的所有语句放到IIFE中，就能够关注作用域。并且HTML文件中不用调用函数。
IIFE是个好东西，能够管理住作用域，函数的闭包能够保护函数的每个变量与别人不冲突
没毛病，有瑕疵，不方便二次使用这个函数。当页面上有两个轮播图的时候，同样的业务，必须要定义两次函数。而函数天生是要复用的，所以IIFE有缺陷。
##### 2.2 js文件中定义函数，在HTML页面上用()调用
这种调用函数的方式，就是用()来进行普通调用。没毛病，函数确实被复用了。
最近学过一种新的函数调用方式，就是用new来调用函数。实际上new就叫做组件开发
我们现在来稍微了解一下JS的垃圾回收机制，来看下面的语句：
````javascript
function fun(){
	var a = 1;
	a++;
	a*=9;
	alert(a);
}

fun();
````
当函数运行的时候，a变量将开辟一小块内存空间，存入1这个数字。然后数值发生变化，弹出数字18。然后js发现a变量没有被任何的定时器、事件监听“持有”，所以为了清理内存，JS就把a当做垃圾了。就回收了这个空间。

你看下面的语句：
````javascript
function fun(){
	var a = 1;
	document.onclick = function(){
		a++;
		alert(a);
	}
}

fun();
````
变量a被事件监听持有，所以fun虽然运行完毕了，但是浏览器不敢去清除a变量的空间。
所以每次点击页面，会弹出2、3、4、5、……。
##### 2.3 js文件中定义类，HTML中用new来调用函数
轮播图是new出来的。实际上就叫做组件开发。组件开发没别的，无非就是代码组织的一种方式。不学组件开发，页面也嗷嗷做，用函数风格， 也没啥问题，但是逼格不高。现在越来越流行把代码做成组件。
轮播图，与打气球、挡板球、贪吃蛇比，太简单了！
杂碎知识点：
写在prototype里面的函数，对象的实例是可以调用的。但是一些函数是内部函数，我们只希望函数自己调用自己。不希望实例来调用，习惯上写_开头命名。但是_不能阻止外部实例调用，没事儿，这就是一个约定。
```javascript
Slider.prototype._findMyElemsByClassName = function(className){

}
```
加上_的函数，说白了不向外暴露这个API。
 I’m so sorry，之前讲正则表达式没有说构造函数法和字面量法的区别。
字面量法，必须是正则表达式的字面量，用/  /来界定。里面不能有变量，不能有斩断链接。
但是，new RegExp()构造函数的语法：
```javascript
var reg = new RegExp(正则字符串,描述符字符串);
```
比如：
```javascript
var reg = new RegExp("^1[\d]{10}$","g");
```
好处就是可以用字符串的斩断链接，来拼接字符串，使用变量：
```javascript
var a = "kaola";
var reg = new RegExp("^" + a + "{1,2}$" , "g");
reg.test("woaikaolahahaha")
```
组件开发有一个天大的好处，就是不用依赖任何的框架。我们不需要使用jQuery，也不需要使用运动框架。
运动框架的哲学是什么？就是把任何的运动都封装：
```javascript
animate(oDiv,{"top":700,"left":700},100);
```
但是组件开发有一个思路，就是自己只管自己，不需要更多的复用。你想想看，传统轮播图中，能够运动的业务，就是left值。只涉及left值的改变，不涉及其他属性的改变，那为什么还要使用万能的运动框架呢？
组件的哲学和通用轮子不一样。通用轮子，要把所有浏览器、所有属性都要封装进来，注重复用、易用。组件开发只针对特定功能！！
当一个变量内部是一个setInterval、setTimeout的时候，那么这个变量被console.log输出的时候，变量的值是1。当定时器积累的时候，实际上值会变。不管怎么样，值正数。
这是一种非常简单的函数截流：
```javascript
if(this.timer){return;}
```
### React
#### React Webpack配置
##### webpack配置
引入babel-loader翻译js文件，但babel-loader依赖babel-core 所以webpack 要安装这两个包,还需要装babel-preset-es2015 //需要注意三个的版本差异
npm install babel-loader babel-core babel-preset-es2015 -D

配置react！安装react
npm install react -D  //为什么是开发依赖？为什么不用bower安装而是npm安装
1.react并不是在html里引入而是在js中import导入,所以npm安装都会node_modules文件夹里，import导入会自动寻找node_modules文件夹
2.


安装完依赖，webpack.config.js babel-loader中presets要增加一项react,
```json
{
                test:/\.js$/,
                exclude: /(node_modules|bower_components)/ ,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['es2015','react']
                    }
                }
            }
```
增加这项只之后又要安装一个```babel-preset-react```，不然```webpack```会报错
#### 组件
​	组件让你将UI拆分为一个个独立的、可以复用的块，并且每一个块都是独立的。组件很像JavaScript函数。它们接受任意数量的参数（我们称为props），并且返回React Elements，这些React Elements描述了组件长得样子。
##### 函数式组件
```jsx harmony
import React from "react";
import ReactDOM from "react-dom";
//这是一个函数，它返回了jsx
function showHello(){
    return <h1>你好</h1>
}
ReactDOM.render(
  <div>
    {showHello()}
  </div>
  ,
  document.querySelector("#app-container")
);
```
>将上面的函数做两个变化：①将函数的名字变为大写； ②调用的时候采用HTML的标签的形式：

React中的组件的名字是大写字母开头的！
```jsx harmony
import React from "react";
import ReactDOM from "react-dom";
//定义一个函数，函数名字是大写，暗示这是个组件
function ShowHello(){ //函数名小写会报错,一定要大写
    return <h1>你好！哈哈！</h1>;
}
ReactDOM.render(
    <div>
        <ShowHello></ShowHello> {/*如果函数小写这里小写也会报错=><showHello></showHello>*/}
    </div>
    ,
    document.querySelector("#app-container")
);
//这就是最简单的组件！
```
##### 组件三大特点
> 组件是可复用的
```jsx harmony
//定义一个函数，函数的名字是大写的，暗示这是一个组件
function ShowHello(){
    return <h1>你好！我爱你！</h1>;
}
ReactDOM.render(
    <div>
        <ShowHello></ShowHello>
        <ShowHello></ShowHello>
        <ShowHello></ShowHello> {/*复用*/}
        <ShowHello></ShowHello>
        <ShowHello></ShowHello>
    </div>,
    document.querySelector("#app-container")
);
```
>组件之间是相互独立的
这里有一个重要知识点：```React中自定义组件是通过标签的自定义的属性来往组件中传值的：```
```jsx harmony
//定义一个函数，函数的名字是大写的，暗示这是一个组件
function ShowHello({a=10000}){
    return <h1>你好！我爱你{a}年！</h1>;
}
ReactDOM.render(
    <div>
        <ShowHello a={34}></ShowHello>
        <ShowHello a={123}></ShowHello>
        <ShowHello a={3455}></ShowHello>
        <ShowHello a={34444}></ShowHello>
        <ShowHello></ShowHello>
    </div>
    ,
    document.querySelector("#app-container")
);
```
>组件可以任意组合的！
我们现再封装一个大组件，叫做ShowMain，里面可以使用小组件：
```jsx harmony
function ShowHello({a=10000}){
    return <h1>你好！我爱你{a}年！</h1>;
}
function ShowMain(){
    return <section>
        <div>广告</div>
        <ShowHello></ShowHello>
    </section>
}
ReactDOM.render(
    <div>
        <ShowHello a={34444}></ShowHello>
        <ShowHello></ShowHello>
        <ShowMain></ShowMain>
    </div>
    ,
    document.querySelector("#app-container")
);
```
##### 类组件
```jsx harmony
import React , {Component} from "react";
//我们定义一个叫做App的组件，在HTML中可以用<App></App>来使用它
//React要求自定义组件必须是大写字母开头！
//React要求自定义组件的类必须继承于React.Component类
class App extends Component{
  constructor(props){
   //调用超类的构造函数，语法规定
    super(props);
  }
  //组件中最重要的方法就是render方法，render是渲染的意思
  render(){
  //返回一个jsx语法，非常牛逼语法
  return <h1>我是React类组件，很高兴遇见你！说{5000+5000}次我爱你！</h1>;
  }
}
//向外暴露
export default App;
```
在使用的时候main.js，进行引包，然后就可以用自定义标签的形式来进行调用。
```jsx harmony
import React from "react";
import {render} from "react-dom";
//引入组件
import App from "./App.js";
//使用、挂载组件，两个参数
//第一个参数是jsx语法
//第二个参数表示组件挂在哪里
render(
	<App></App> ,
	document.getElementById("app-container")
);
```
>**总结类组件的书写：**
 1）每一个类组件都是单独的文件，文件的名字必须和类的名字完全相同！类的名字大写字母开头！
 2）类必须继承自React.Component类，所以要引入react包;
 3）类的构造器中，必须调用超类的构造器，super(props); 
 4）界面用render()方法返回jsx即可！ 
 5）记得暴露！！

##### JSX语法：

​	有意思的语法，这里不是HTML也不是字符串。 它被叫做JSX，是一个JavaScript语法的拓展。我们推荐用JSX语法来写React，它用来描述UI长成什么样子。JSX可能让你想起模板引擎（比如ejs、php），但是它拥有JavaScript全部的能力。 JSX生产了React的“elements”。

**需要注意：**

> jsx不能直接运行，是被babel-loader中的react这个preset翻译的
```json
{
     test:/\.js$/,
     exclude: /(node_modules|bower_components)/ ,
     use: {
     loader: 'babel-loader',
     options: {
          presets: ['es2015','react'] 
     }
          }
}
```
> 必须被一个单独的大标签包裹，比如div或者section


```jsx harmony
//错误的：
return <h1>我是React，很高兴遇见你！HAHAHAHA</h1>
<h1>我是React，很高兴遇见你！HAHAHAHA</h1>;
//正确的：应该被一个div包裹起来，小括号也挺好用的：
return (
	<div>
		<h1>我是React，很高兴遇见你！HAHAHAHA</h1>
		<h1>我是React，很高兴遇见你！HAHAHAHA</h1>
	</div>
);
```
>标签必须封闭
```jsx harmony
//错误的：
return (
	<div>
		<img src="" >
	</div>
);
//正确的：
return (
	<div>
		<img src="" />
	</div>
);
```
>class要写成className，for要写成htmlFor
```jsx harmony
//错误的：
return (
	<div>
	  <div class="box" ></div>
	</div>
);
//正确的：
return (
	<div>
	  <div className="box" ></div>
	</div>
);
```
>HTML注释不能使用，只能使用JS注释。
```

```
>原生标签比如p、li、div如果要使用自定义属性，必须用data-前缀

```jsx harmony
//错误：
return (
  <div>
	<h1>我是React，很高兴遇见你！</h1>
	<p a="10"></p>
  </div>
);
//正确：
return (
  <div>
	<h1>我是React，很高兴遇见你！</h1>
	<p data-a="10"></p>
  </div>
);
```
>如果是自定义标签，随便传属性：
```jsx harmony
<App a="123213"></App>
```
>JS表达式用{}单大括号包裹，在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.
```jsx harmony
<h1>我是React，很高兴遇见你！{1+2}</h1>
{3 > 8 ? "A" : "B"}
```
>可以运行函数：
```jsx harmony
import React from "react";
//我们定义一个叫做App的组件，在HTML中可以用<App></App>来使用它
//React要求自定义组件必须是大写字母开头！
//React要求自定义组件的类必须继承于React.Component类
class App extends React.Component{
	//定义一个函数haha，接受一个参数
	haha(lanmu){
	  if(lanmu == "篮球"){
		return (
		  <ul>
			<li>乔丹</li>
			<li>科比</li>
			<li>奥尼尔</li>
		  </ul>
		)
	  }else if(lanmu == "足球"){
	    return (
	      <ul>
			<li>李铁</li>
			<li>郝海东</li>
			<li>C罗</li>
	      </ul>
		)
	  }
	}
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
	  return (
	    <div>
		  <h1>我是React，很高兴遇见你！</h1>
			<h3>JSX语法很好用哦！</h3>
			{3 > 8 ? "A" : "B"}
			<h3>JSX可以调用函数哦！</h3>
			{this.haha("足球")}
	    </div>
	  );
	}
}
//向外暴露
export default App;
```
>样式使用双大括号
```jsx harmony
<h3>JSX可以设置样式哦！</h3>
<div style={{"width":"100px","height":20 + 30 + "px","backgroundColor" : "red"}}></div>
```
>可以使用数组，数组中如果是JSX语法，数组会被自动展开。所以不需要使用ng-repeat这样的指令展开数组。
#### React中的数据传递
React中跟数据有关系的就三个东西：state、props、context。我们可以叫做数据传递三兄弟。
##### 组件自己身上的属性
组件自己身上的属性值变化，不会引起视图改变
我们可以在组件的类定义里面写constructor构造器，里面定义`this.a = 100` 。表示给组件的实例绑定一个`a`属性，值是`100`。在jsx中使用的时候，直接`this.a`即可。
```jsx harmony
import React from "react";
class App extends React.Component{
  //构造函数
  constructor(props){
    super(props);  //要求调用super
	this.a = 100;
  }
  add () {
    this.a++;
    console.log(this.a); //点击按钮的时候this.a确实变化了，但是视图没有更新，所以React中，组件自己的属性的变化不会引发视图的变化！！
  }
  //组件中最重要的方法就是render方法，render是渲染的意思
  render(){
  //返回一个jsx语法，非常牛逼语法
	return (
	  <div>
	    {this.a}
	    <button onClick={this.add.bind(this)}>点我++</button>
	  </div>
	);
  }
}
//向外暴露
export default App;
```
① 绑定监听使用onClick、onMousedown、onMouseenter、onBlur，把on后面的字母大写，React会自动识别React事件。
② 绑定监听函数的时候，this上下文是有问题的，所以需要使用bind()方法来设置上下文
③ 绑定监听函数的时候，注意用{}而不是""
```
错误的：
<input type="button" value="按我" onClick="(this.add).bind(this)" />
```
##### 闭包中的值变化，不会引起视图改变
```jsx harmony
import React from "react";
class App extends React.Component{
  render(){
    let b = 99; //这个b在render函数中相当于闭包
	return (
	  <div>
		<p>{b}</p>
		<p>
		  <input type="button" value="按我" onClick={()=>{b++;console.log(b) }} />{/*点击按钮b值确实变化;*/}
		</p>
	  </div>
		);
	}
}
//向外暴露
export default App;
//闭包中的值变化，也不会引起视图的改变！
```
##### 三兄弟之一 ：state
React把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染UI，让用户界面和数据保持一致。
React里，只需更新组件的 state，然后根据新的state重新渲染用户界面（不要操作DOM）。在任何一个类组件（函数式组件没有local state）的构造函数中，可以添加一个state属性，它的值必须是一个对象，叫做组件内部状态。在视图中，可以通过this.state.**的形式来访问得到这个属性值。
```jsx harmony
import React from "react";
export default class App extends React.Component{
    constructor(props){
        super(props);
        //这个就叫做内部state，英语叫做local state
        this.state = {"a" : 100}
    }
    render(){
        return <div>
            <h1>{this.state.a}</h1>
        </div>
    }
}
```
只有更新三兄弟，才会引发Virtual DOM的改变，从而改变DOM。通过`this.setState()`改变`local state`的值,只有组件自己能改变自己的state，别人想改变自己的state，都不可能！
```jsx harmony
import React from "react";
class App extends React.Component{
  constructor(props){
    super(props);
    //这个就叫做内部state，英语叫做local state
    this.state = {
      a : 100,
 	  b : 200,
 	  c : 300
    }
  }
  add(){
    this.setState({a : this.state.a + 1});
  }
  render(){
    return (
      <div>
 		<h1>我是APP组件</h1>
 		<p>我有状态state</p>
 		<p>a : {this.state.a}</p>
 		<p>b : {this.state.b}</p>
 		<p>c : {this.state.c}</p>
 		<p>
 		  <input type="button" value="按我" onClick={(this.add).bind(this)}/>
 		</p>
      </div>
    )
  }
}
/*
定义state： 在构造函数中使用this.state属性即可
使用state ：在JSX中{this.state.a}
*/
export default App;
```
​	数据变化了！视图就自动发生变化！这是MVVM框架的最基本的诉求。**注意，改变state的值，必须使用this.setState()方法，如果直接使用this.state.xx = xx的语法，此时视图不会变化！** 也就是说，setState()暗含有调用render方法的语句！（明天你将知道，实际上setState()将组件的生命周期进行了等级跃迁）。后面要介绍Redux架构，所有组件自己的state越来越少用了，而是变为了Redux中的state，不要混淆
##### 4.4props
就是定义在自定义组件标签上面的值，就是props。当props改变的时候，会引发Virtual DOM的改变，从而引发视图的重绘。
react崇尚数据的单向流动，所以设计的时候就是让数据从父组件流向子组件。props在子组件中是只读的，不能修改的。
如果父组件App，想往子组件MyCompo中传值，使用属性：
```jsx harmony
//app.js：
import React from "react";
import MyCompo from "./MyCompo.js";
class App extends React.Component{
  constructor(props){
    super(props);
  }
  render(){
    return (
      <div>
 		<MyCompo a="66" b="77" c="88"></MyCompo>
      </div>
 	)
  }
}
//向外暴露
export default App;
```
子组件MyCompo中就可以无脑使用this.props来枚举传入的属性：
```jsx harmony
//MyCompo.js:
import React from "react";
class MyCompo extends React.Component{
  constructor(props){
    super(props);
  }
  render(){
    return (
      <div>
 		我是MyCompo组件
 		<p>{this.props.a}</p>
 		<p>{this.props.b}</p>
 		<p>{this.props.c}</p>
      </div>
 	);
  }
}

//向外暴露
export default MyCompo;
```
如果需要在构造函数中使用这个值，此时系统会将props最为构造函数的第一个参数传入：
```jsx harmony
class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			c : props.c
 		}
 	}
 }
//在子组件中，props是只读的，不能修改props的值。如果要修改，用state来接收。
```
##### props是标签上的属性可以被验证有效性：
npm install --save-dev prop-types //react分离了
```jsx harmony
import React from "react";
import { PropTypes } from "prop-types";
class MyCompo extends React.Component{
  constructor(props){
    super(props);
      this.state = {
        c : props.c
      }
  }
 	//MyCompo.propTypes={}  //propTypes不能写在实例上，这是类的属性，只能在外面挂载
  render(){
    return (
      <div>
 		我是MyCompo组件
 		<p>{this.props.a}</p>
 		<p>{this.props.b}</p>
 		<p>{this.state.c}</p>
 		<p>
 		  <input type="button" value="按我" onClick={()=>{this.setState({c : this.state.c + 1});}}/>
 		</p>
      </div>
 	);
  }
}
//定义组件需要传入的参数，这些都是语法规定
//类名.propTypes，值是一个JSON。key就是需要传进来的props属性名，v就是对它的限制,propTypes不能写在实例上
MyCompo.propTypes = {
	a : PropTypes.string.isRequired,  	//a属性是一个字符串，必传
	b : PropTypes.string,  				//b属性是一个字符串，不必传
	c : PropTypes.number.isRequired		//c属性是一个数组，必传
};
//向外暴露
export default MyCompo;
```
#### 子组件传父组件
如果非要从下到上传输数据呢？子组件要把数据返回给父组件，此时只能用奇淫技巧。就是父组件传一个函数给子组件，
子组件通过传参数调用函数将数据返回给父组件的函数，父组件的函数接受实参改变父组件中的state等值。
父组件App现在想让子组件MyCompo设置App自己的state.d值，此时就需要传入d值，并且传入一个设置d值的函数到子组件：


#### 三兄弟之三：context
上下文的精髓是可以跨级传递数据，爷爷组件可以直接传递数据到孙子组件。
语法比较晦涩：
#### 五、其他API
##### 5.1 无状态组件
当我们现在的组件仅仅是为了呈递一些DOM元素，没有state、props等东西，此时可以不用费劲
class My extends React.Component{}
而是一个暴露简单函数即可：
```jsx harmony
//My.js
import React from "react";
export default () => {
	return (
		<div>
			<h1>我是My组件</h1>
		</div>
	)
}
```
此时真的可以用它：
```jsx harmony
import React from "react";
import My from "./My.js";
class App extends React.Component{
 	constructor(props){
 		super(props);
 	}
 	render(){
 		return (
 			<div>
 				<My></My>
 			</div>
 		)
 	}
}
//向外暴露
export default App;
```
#### 5.2 默认属性
如果没有传入name输入，那么就以“菜鸟”作为属性：
```jsx harmony
	constructor(props){
		super(props);
    this.state = {
         name : props.name || "菜鸟"
        }
	}
	//现在很少用getDefaultProps了
```
#### 组件的生命周期
组件从没有诞生到诞生，到被移除的完整生命周期，都提供了可以触发事件的函数接口，就是生命周期。
组件的生命周期包含三个主要部分：

>挂载上树阶段（Mounting阶段）： 组件被插入到DOM中。
更新阶段（Updating阶段）： 组件被重新渲染，查明DOM是否应该刷新。
移除下树阶段（Unmounting阶段）： 组件从DOM中移除。
```jsx harmony
import React from "react";
class App extends React.Component{
 //挂载之前Mounting阶段包含四个：constructor,componentWillMount,render,componentDidMount。这个四个方法将在组件创建了、上树的时候被按顺序调用。本阶段需要注意的是，在componentDidMount()生命周期函数中，就能操作DOM了，DOM就已经上树了；本阶段的4个函数都没有参数。
 constructor(props){
   super(props);
 }
  componentWillMount(){
		console.log("componentWillMount");
  }
  render(){
    return (
      <div>生命周期</div>
 	)
  }
  //在挂载结束之后马上被调用。需要DOM节点的初始化操作应该放在这里。
  componentDidMount(){
    console.log("componentDidMount");
 }
//更新阶段（Updating阶段）:props的改变或者state的改变将触发本阶段。componentWillReceiveProps(nextProps),shouldComponentUpdate(nextProps, nextState),componentWillUpdate(nextProps, nextState),render(),componentDidUpdate(prevProps , prevState)
  componentWillReceiveProps(nexProps){//当父亲传给组件的prop改变的时候发生。在这个函数中，nextProps参数表示新的父亲传入的props对象
  
  } 
  shouldComponentUpdate(nextProps , nextState){//当组件做出是否要更新DOM的决定的时候被调用。“门神”，在改变状态的时候可以选择通过或者不通过。
 		if(nextState.a > 0.8){
 			return true;
 		}
 		alert("本次没有随机到大于0.8的，更新被阻止");
 		return false;
 	}
 componentWillUpdate(){//在更新发生之前被调用，没有把门的功能
   console.log("componentWillUpdate");
 }
 	//下树阶段（Unmounting阶段）:componentWillUnmount
 componentWillUnmount(){ //在组件移除和销毁之前被调用
   console.log("componentWillUnmount");
 }
}
```
##### 防止生命周期死循环
只要进入了某一个阶段，则这个阶段的生命周期都会做。
所以在Updaing整个阶段中，5个生命周期：`componentWillReceiveProps`、`shouldComponentUpdate`、`componentWillUpdate`、`render`、`componentDidUpdate`中，都不能操作state！如果操作了state，则再来一遍！子子孙孙无穷匮也，就死循环了。

#### 5.4 React中的表单
React没有提供类似Angular中复杂的表单验证功能，也没有双向数据绑定！
如果非要做一个效果：文本框中输入内容，实时改变h1中的内容此时就要用模拟的方法，监听文本框的事件，然后改变组件的state状态。

```jsx harmony
import React from "react";
class My2 extends React.Component{
	constructor(props){
		super();
	 	this.change = (this.change).bind(this);
	 	this.state = {
	 		"txt" : ""
	 	}
	}
	change(event){
		this.setState({"txt" : event.target.value });
	}
	render(){
		return (
			<div>
			 	<input type="text" onInput={this.change} />
			 	<h1>{this.state.txt}</h1>
 			</div>
		)
	}
}
export default My2;
```
##### ref DOM钩子
```jsx harmony
//有时候需要操作DOM元素，ref属性表示一个钩子。可以在其他地方使用this.refs来获得这个DOM元素。
import React from 'react';
class My3 extends React.Component{
    constructor (){
        super();
        this.handleChange =this.handleChange.bind(this);
    }
    handleChange(){
        this.refs.mybox.style.background='red';
        console.log(this.refs.mybox);
    }
    render(){
        return(
            <div>
                <input type="button" onClick={this.handleChange}/>
                <div ref="mybox" style={{width:'100px',height:'100px',backgroundColor:'orange'}}></div>
            </div>
        )
    }
}
export default My3;
```
##### 受控组件和非受控组件
###### 2.2 受控组件
受控组件中的所有表单元素，都使用onChange和value属性和state进行模拟“双向绑定”。
```jsx harmony
import React from "react";
export default class App extends React.Component{
    constructor(props){
        super(props);
        this.state = {
            name : "",
            age : ""
        }
    }
    submitHandeler(){
       alert("提交了！" + JSON.stringify(this.state)); 
    }
    changeName(name){
        this.setState({ name });
    }
    changeAge(age){
        this.setState({age});
    }
    render(){
        return <div>
            <p>
                姓名：
                <input 
                    type="text" 
                    value={this.state.name} 
                    onChange={(e)=>{ this.changeName(e.target.value) }}
                />
            </p>
            <p>
                年龄：
                <input 
                    type="text" 
                    value={this.state.age}
                    onChange={(e) => { this.changeAge(e.target.value) }}
                />
            </p>
            <button onClick={this.submitHandeler.bind(this)}>提交</button>
        </div> 
    }
}
```
###### 非受控组件
下面的表单中，有两个输入框一个按钮，输入框都有ref属性，ref属性便于我们的程序取得它们的值。点击按钮之后，直接通过this.refs.**来取得文本框的值，然后提交。这里面丝毫没有用到state，没有对组件的state产生任何改变。
```jsx harmony
import React from "react";
export default class App extends React.Component{
  constructor(props){
    super(props);
  }
  submitHandeler(){
    let name = this.refs.nameTxt.value;
    let age = this.refs.ageTxt.value;
    alert("提交了数据" + name + age);
  }
  render(){
    return (
      <div>
        <p>
          姓名：<input type="text" ref="nameTxt"/>
        </p>
        <p>
          年龄：<input type="text" ref="ageTxt"/>
        </p>
        <button onClick={this.submitHandeler.bind(this)}>提交</button>
      </div>
    )
  }
}
```
###### ref和e.target.value
ref是非受控组件中用的，受控组件绝对出现不了ref这个东西。ref表示组件内部的选择，表单控件身上加ref
```jsx harmony
<input type="text" ref="nameTxt"/>
//得到它的值：this.refs.nameTxt
```
受控组件中，组件自己要和state进行模拟“双向数据绑定”。此时`onChange`事件中，要把自己的值传出去，此时就要写一些箭头函数，将小e对象的`e.target.value`属性传出去。在JS进阶中老师告诉大家，`e.target`就是`e.srcElement`，表示获得事件的最小元素。
```jsx harmony
<input type="text" onChange={(e)=>{this.changeHandler(e.target.value)}} />
```
#### Redux
>Redux is a predictable state container for JavaScript apps.
Redux是一个可以预测状态的JS app容器。
通过例子来学习Redux：
The whole state of your app is stored in an object tree inside a single store.
你的App中全部的state都被存储在一个单独的store中，形式是object tree。
The only way to change the state tree is to emit an action , an object describing what happened
唯一的更改state的途径就行emit一个action，这个action描述了发什么什么事。
To specify how the actions transform the state tree, you write pure reducers
为了指定这些actions如何改变state tree，你必须书写简单的、纯净的reducers。

​	我们先用一个最最简单的案例，学习Redux,我们从Redux的官方github上的example文件夹中，下载这个案例。网址：[1]https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html只有一个index.html页面，这个案例和React没有关系！具体代码见案例，笔记上是代码的剖析。

###### Reducer - 实现可被预测的状态
下面这个函数就是reducer，这里就是所谓的“predictable”可以被预测的含义。所有对state的操作，都要罗列出来。
reducer函数必须符合的形态：接受之前的state和action，返回新的state：
```javascript
function counter(state = {"v" : 100} , action){
    if(action.type == "ZENGJIA"){
        return {"v" : state.v + 1};
    }else if(action.type == "JIANSHAO"){
        return {"v" : state.v - 1};
    }
    return state;
}
```
在reducer中是绝对不能更改state的，而是应该返回新的state。
###### 创建Store，并且注册视图
store存储了state数据，并且维持了一套操作state的API，就是reducer。
```javascript
var store = Redux.createStore(counter);
```
>store有几个功能：
    可以读取数据，通过store.getState();
	允许更新state，通过store.dispatch(action);
	注册视图，通过，subscribe(listener);

```javascript
store.subscribe(render);
```
###### 发送action
按钮监听不是直接改变state的值，而是调用store的dispatch方法发送命令给仓库，比对reducer中的if语句，执行相应的改变。
````javascript
document.getElementById("jiaBtn").onclick = function(){
  store.dispatch({"type" : "ZENGJIA"});
}
document.getElementById("jianBtn").onclick = function () {
  store.dispatch({ "type": "JIANSHAO" });
 }
````
```html
<!DOCTYPE html>
<html>
<head>
    <title>Redux</title>
    <script src="redux.min.js"></script>
</head>
<body>
    <div>
        <h1 id="title">0</h1>  
        <button id="jiaBtn">+</button>
        <button id="jianBtn">-</button>
    </div>
    <script>
        //这个函数我们称为reducer，这个函数接受两个参数state和action，返回新的state。
        //这里罗列了所有action会导致的state的变化
        //对于state的形式取决于你，可以是一个基本值，可以是一个对象。
        //下面的案例中，state是一个对象，并且初始值已经通过ES6的默认属性特性，写在了圆括号中，就是v:100
        //你看，这个函数里面通过if语句分支，根据action的type属性不同，返回了不同的state。
        //state的v值要么被加了1；要么被减了1。但是，都是返回的新的state，没有直接改变原来的state。
        function counter(state = {"v" : 100} , action){
            if(action.type == "ZENGJIA"){
                return {"v" : state.v + 1};
            }else if(action.type == "JIANSHAO"){
                return {"v" : state.v - 1};
            }
            return state;
        }
        //store我们叫做“仓库”是存储、管理state的地方。
        //创建仓库需要提供reducer，也就是说store是存储state的地方，而reducer是对数据一系列可能的操作。
        var store = Redux.createStore(counter);
        //得到DOM元素
        var oTitle = document.getElementById('title');

        //这里写一个render函数，sotore.getState()从仓库中取出state。让DOM的html显示
        function render(){
            oTitle.innerHTML = store.getState().v;
            console.log(store.getState());
        }
        //调用一下
        render();
        //将store注册到视图，这样一旦store中的数据变化，就会自动调用render函数
        store.subscribe(render);
        //按钮的监听
        //改变state的唯一的方法就是要dispatch一个action。action我们叫做“命令”。
        //至此，我们用Redux.createStore(reducer)造出来的store小王八蛋，调用了三个方法：
        //  store.getState();   从仓库中读值
        //  store.subscribe()   将store注册到视图，store一变化，自动改变视图
        //  store.dispatch();   发送命令
        document.getElementById("jiaBtn").onclick = function(){
            store.dispatch({"type" : "ZENGJIA"});
        }
        document.getElementById("jianBtn").onclick = function () {
            store.dispatch({ "type": "JIANSHAO" });
        }
    </script>
</body>
</html>
```
##### Redux深入
>我们自己试着实现一个变量私有化、可预测变量状态的小东西，我们要私有化一个a，让a可以被预测：
1）正着说：所有对a的操作，都要罗列出来；
2）反着说：对a操作只能通过我们罗列的函数。

所以我们利用了JS中的闭包特性，在一个大函数的里面定义一个a变量，这个大函数返回一个对象，这个对象以KV对儿的形式，返回了一组对闭包a操作的函数，我们叫做API：
```javascript
function createStore(){
    var a = 100;   //这就相当于state
    return {		//这就相当于reducer
        getValue : function(){
            return a;
        },
        add : function(){
            a++;
        },
        minus : function(){
            a--;
        }
    }
}
```
接下来就能使用了，我们发现要想读取a、操作a必须使用我们提供的API：
```javascript
var store = createStore();
console.log(store.getValue()); //读取
store.add(); //加1
store.add();
store.add();
store.add();
console.log(store.getValue());
```
a是绝对不可能被乘2的，这就叫做可以预测状态。
下面就是完整的Redux版本的计数器：
```html
 <script>
        //这里就是一个reducer，函数头(state,action)=>state
        function reducer(state = {"v" : 100} , action){
            if(action.type == "ADD"){
                return {
                    ...state,
                    "v" : state.v + 1
                }
            }else if (action.type == "MINUS") {
                return {
                    ...state,
                    "v": state.v - 1
                }
            }
            return state;
        }

        const store = Redux.createStore(reducer);

        //视图函数
        //在纯Redux中，这里显式地写了一个render函数，这样的话我们点击按钮的时候只需要发送action改变state，而不需要操作DOM。
        //为什么要写这个render函数呢？因为我们没有类似JSX的{}的侵入式的HTML模板标记。
        function render(){
            document.getElementById("title").innerHTML = store.getState().v;
        }
        render();

        //注册视图
        store.subscribe(render);

        document.getElementById("btn1").onclick = function(){
            store.dispatch({"type" : "ADD"})
        }

        document.getElementById("btn2").onclick = function () {
            store.dispatch({ "type": "MINUS" })
        }
    </script>
```
我们做几点非常重要的说明：
不管业务程序有多大，state、reducer、store只有一组。
比如我们现在我们有计数器和学生列表两个功能，reducer确实是将他们合二为一。
虽然业务有两部分：计数器、学生清单，但是reducer一个，绿色背景的是计数器的业务，蓝色背景的是学生清单的业务。
```javascript
function reducer(state =  defaultState, action){
    if(action.type == "ADD"){
        return {
            ...state,
            "v" : state.v + 1
        }
    }else if (action.type == "MINUS") {
        return {
            ...state,
            "v": state.v - 1
        }
    } else if (action.type == "ZENGJIAXUESHENG") {
        return {
            ...state,
            "students" : [
                ...state.students ,
                {"id" : action.id , "name" : action.name}
            ]
        }
    } 
    return state;
}
```
此时为了reducer的形式规整，我们可以拆分为策略模式。
```javascript
//策略对象，这个策略对象负责计数器
var counterStrategies = function(state , action){
    return {
        "ADD": {
            ...state,
            "v": state.v + 1
        },
        "MINUS": {
            ...state,
            "v": state.v - 1
        }
    }
}

//策略对象，这个策略对象负责学生清单
var studentsStrategies = function (state, action) {
    return {
        "ZENGJIAXUESHENG": {
            ...state,
            "students": [
                ...state.students,
                { "id": action.id, "name": action.name }
            ]
        }
    }
}

//这里就是一个reducer，函数头(state,action)=>state
function reducer(state =  defaultState, action){
    //策略模式和职责链模式
    if(counterStrategies(state , action)[action.type]) return counterStrategies(state,action)[action.type];
    if(studentsStrategies(state , action)[action.type]) return studentsStrategies(state,action)[action.type];
    return state;
}
```
为了方便代码压缩，所有的Action的大写字母Type可以单独写为一个外置文件.向外暴露add，本质是字符串"ADD"，目的何在？方便代码压缩，代码中没有必要大量出现"ADD"字样。
```javascript
var add = "ADD";
var minus = "MINUS";
var zengjiaxuesheng = "ZENGJIAXUESHENG";
```
命名空间也有了：
```javascript
var counter1 = {
    add : "ADD",
    minus: "MINUS"
}
var zengjiaxuesheng = "ZENGJIAXUESHENG";
```
使用的时候要加上namespace：
```javascript
//策略对象，这个策略对象负责计数器
var counterStrategies = function(state , action){
    return {
        [counter1.add]: {
            ...state,
            "v": state.v + 1
        },
        [counter1.minus]: {
            ...state,
            "v": state.v - 1
        }
    }
}
```
###### action creator
返回action的函数我们叫做action creator。
我们现在做一个顶层命名空间actions，里面有二层命名空间叫做counter，列出一个个返回Action对象的函数。我们把add函数、minus函数叫做action creator。
```javascript
var actions = {
    "counter" : {
        add(n = 1){
            return { "type": counter1.add , n} ;
        },
        minus(){
            return { "type": counter1.minus };
        }
    }
}
```
#### React和Redux结合
##### redux和react-redux介绍
到目前为止，我们的原生React的项目的开发依赖和运行依赖：
```json
{
"devDependencies": {
    "babel-core": "^6.26.0",
    "babel-loader": "^7.1.2",
    "babel-plugin-transform-object-rest-spread": "^6.26.0",
    "babel-preset-env": "^1.6.1",
    "babel-preset-react": "^6.24.1"
  },
  "dependencies": {
    "classnames": "^2.2.5",
    "react": "^16.1.1",
    "react-dom": "^16.1.1"
  }
}
```
我们现在要把react和redux结合起来，我们需要增加2个运行依赖：
>redux : 提供诸如createStore()、bindActionCreator()、combineReducer()等等redux的常用功能，都是函数；
>react-redux ：就是将react和redux绑定在一起时需要的小工具，里面就提供了两个功能，<Provider>组件和connect()函数。
>

##### react和redux结合制作计数器
第一步，创建reducer文件，所以我们在app文件夹中创建reducers文件件，在内创建index.js文件
```javascript
export default (state = {"v" : 100} , action) => {
    return state;
}
```
第二步，在main.js中创建store。
```jsx harmony
import React from "react";
import ReactDOM from "react-dom";
import {createStore} from "redux";
import App from "./App.js";
import reducer from "./reducers/index.js";
//创建store，创建store要提供reducer
const store = createStore(reducer);
ReactDOM.render(
    <App></App>
    ,
    document.getElementById("app-container")
);
```
 第三步，共享这个store让所有组件可以看见。
 ```jsx harmony
import React from "react";
import ReactDOM from "react-dom";
import {createStore} from "redux";
import {Provider} from "react-redux";
import App from "./App.js";
import reducer from "./reducers/index.js";
//创建store，创建store要提供reducer
const store = createStore(reducer);
ReactDOM.render(
    <Provider store={store}>
        <App></App>
    </Provider>
    ,
    document.getElementById("app-container")
);
```
>Provider干嘛的呢？答：Makes the Redux store available to component hierarchy below. 让所有下辖的组件都能够使用store。
>
第四步，更改App组件，引入connect函数，将App进行装饰之后暴露！
```jsx harmony
import React from "react";
import {connect} from "react-redux";
class App extends React.Component{
  constructor(props){
    super(props)
  }
  render(){
    return <div>我是App组件</div>
  }
}
export default connect()(App);
```
第五步，给connect函数里面增加第一个参数，是一个函数，这个函数叫做mapStoreStateToProps，将store中的state和组件的props进行合并、映射。在组件的JSX中，使用this.props.v来得到store中的v值。也就是说，我们的v感觉就是props的一部分。
```jsx harmony
import React from "react";
import {connect} from "react-redux";
class App extends React.Component{
    constructor(props){
        super(props)
    }
    render(){
        return <div>
            <h1>{this.props.v}</h1>
        </div>
    }
}
export default connect(
    //mapStoreStateToProps
    (state)=>{
        return {
            v : state.v
        }
    }
)(App);
```
第六步，加按钮。我们要先改变app/reducers/index.js中的reducer函数：
```jsx harmony
export default (state = {"v" : 100} , action) => {
    if(action.type == "ZENGJIA"){
        return {
            ...state , 
            "v" : state.v + 1
        }
    }else if(action.type == "JIANSHAO"){
        return {
            ...state ,
            "v" : state.v - 1
        }
    }
    return state;
}
```
更改App组件，我们给connect函数增加第二个函数。
```jsx harmony

import React from "react";
import {connect} from "react-redux";

class App extends React.Component{
    constructor(props){
        super(props)
    }

    render(){
        return <div>
            <h1>{this.props.v}</h1>
            <button onClick={this.props.add}>按我加1</button>
            <button onClick={this.props.minus}>按我减1</button>
        </div>
    }
}

export default connect(
    //mapStoreStateToProps
    (state)=>{
        return {
            v : state.v
        }
    },
    (dispatch)=>{
        return {
            add(){
                dispatch({"type" : "ZENGJIA"});
            },
            minus(){
                dispatch({"type" : "JIANSHAO"});
            }
        }
    }
)(App);
```
##### Provider组件connect()函数
在学习Redux的时候，一定要记住：不管项目有多大，一个app只有一个store！
解释一下下面的库：
>react:全球使用人数最多的MVVM框架，提供了组件、内部state、路由等等；
>redux:独立的库，提供了一个可以被预测状态的、唯一的、全局的变量容器，叫做store，里面有state，用reducer来进行更改。
>将react框架和redux库进行结合，让我们在react开发或中可以使用redux提供的可预测状态的变量容器。react-redux中就提供了两个东西：Provider组件、connect()函数。
>
###### Provider组件
###### connect函数
大语法：
```jsx harmony
export default connect()(组件名字);
```
第一个参数：mapStateToProps
第二个参数：这个参数是一个函数，系统送给我们一个dispatch可以调用，我们return的JSON对象的key也将和props进行融合。我们的按钮，就可以onClick={this.props.add}
```jsx harmony
export default connect(
    (state)=>{
        return {
            v : state.v
        }
    },
    (dispatch)=>{
        return {
            add(){
                dispatch({"type" : "ZENGJIA"});
            }
        }
    }
)(App);
```
###### bindActionCreators()函数
目前为止，我们的connect()函数的风格是：
```jsx harmony
export default connect(
    (state)=>{
        return {
            v : state.v
        }
    },
    (dispatch)=>{
        return {
            add(){
                dispatch({"type" : "ZENGJIA"});
            }
        }
    }
)(App);
```
我们进行一些改动，第一步，创建一个actions文件夹：
```jsx harmony
export const add = () => ({"type" : "ZENGJIA"});
export const minus = () => ({"type" : "JIANSHAO"});
```
第二步，更改组件的connect函数。
```jsx harmony
import React, { Component } from 'react';
import {connect} from "react-redux";
import {bindActionCreators} from "redux";
import * as counterAction from "./actions/counterAction.js";

export class App extends Component {
    render() {
        return (
            <div>
                <h1>{this.props.v}</h1>
                <button onClick={this.props.actions.add}>加</button>
                <button onClick={this.props.actions.minus}>减</button>
                <button onClick={this.props.actions.cheng2}>乘2</button>
            </div>
        )
    }
}

export default connect(
    (state)=>{
        return {
            v : state.v
        }
    },
    (dispatch) => ({
        actions: bindActionCreators(counterAction, dispatch)
    })
)(App);
```
所有的拆分感觉没有意义，是因为我们的程序体量不大，你最后一天回来看看？2017年11月23日15:40:06。
###### combineRucer()函数
当我们的项目大的时候，reducer中势必很多东西（我们最后的项目reducer有7个：汽车图集、汽车档案、订单、管理人员、客户的等等）。
但是还是那句话：
不管项目有多大，一个app只有一个store！
reducer只有一个，但是我们可以用手段来将他们拆分，就是combineReducer()。

三个reducers：
分reducer之一，studentsReducer：
这个reducer感觉不像是总reducer的一个“碎片”，因为它就是标准reducer。
```jsx harmony
const initialState = {
    students: [
        { "id": 10001, "name": "小明" },
        { "id": 10002, "name": "小黄" },
        { "id": 10003, "name": "小春" },
        { "id": 10004, "name": "小龙" }
    ]
}

export default (state = initialState, action) => {
    switch (action.type) {
        case "ZENGJIAXUESHENG":
            return {
                ...state,
                "students": [
                    ...state.students,
                    { "id": action.id, "name": action.name }
                ]
            }
    }
    return state;
}
```
分reducer之一，counterReducer：
```jsx harmony
const initialState = {
  students: [
    { "id": 10001, "name": "小明" },
    { "id": 10002, "name": "小黄" },
    { "id": 10003, "name": "小春" },
    { "id": 10004, "name": "小龙" }
    ]
}
export default (state = initialState, action) => {
  switch (action.type) {
    case "ZENGJIAXUESHENG":
      return {
        ...state,
                "students": [
                    ...state.students,
                    { "id": action.id, "name": action.name }
                ]
            }
    }
    return state;
}
```
合并起来index.js:
```jsx harmony
import { combineReducers } from 'redux'
import counterReducer from "./counterReducer.js";
import studentsReducer from "./studentsReducer.js";
export default combineReducers({
  counterReducer,
  studentsReducer
});
```
#### 3.1 不使用React-Redux遇见的灾难
刚才我们学习了Redux，已经基本知道Redux怎么玩儿了，大致步骤：
设置一个reducer，
弄一个store，从Redux.createStore(reducer);
弄一个render函数
注册一下render，store.subscibe(render)
写监听了，此时要记得store.dispatch(action)，不是直接改store。
此时和React还没有直接产生关系，换句话说在React中没有使用Redux技术
#### 我们现在看一下counter这个案例：
```jsx harmony
import React from 'react';
import ReactDom from 'react-dom';
import counter from './counter';
import Counter from './MyCounter'
import {createStore} from 'redux';
const rootEl = document.getElementById('root')
let store = createStore(counter);
const render = () => ReactDom.render(
    <Counter
        value={store.getState().n}
        increment ={()=>{store.dispatch({type:'INCREMENT'})}}
        decrement={()=>{store.dispatch({type:'DECREMENT'})}}
    ></Counter>,
    rootEl
);
render();
store.subscribe(render);
```
这个案例纯属霸王硬上弓，就是我们现在通过标签的属性，将store的值，和对store的操作传给了组件！这太二了！
```jsx harmony
const render = () => {ReactDOM.render(
  <Counter
	  value={store.getState()}
	  onIncrement={() => store.dispatch({ type: 'INCREMENT' })}
	  onDecrement={() => store.dispatch({ type: 'DECREMENT' })}
  />,
  rootEl
)};

```
那次此时灾难是什么？比如一个组件内部要多store有10种操作，你还传10个属性下去啊？再比如，组件内部还有组件要操作store，你还一直往下传啊？
所以我们使用一个粘合剂，要优雅的把react和redux合并起来，这个包就叫做react-redux。
react-redux可以让任何组件在任何地方看见store，机理实际上就是昨天学习的context。但是我们用的时候和context无关，人家帮我们写好了。
此时我们怎么学习react-redux，还是老方法，结合官方文档看官方demo。
我们要攻克todomvc这个官方dem
#### 3.2 结合官方文档看官方demo(todomvc)
React-Redux给我们提供了两个东西：Provider组件、connect函数。
Provider组件要求是最大的组件，传入store属性，此时天下无人不识君。
官方文档：https://github.com/reactjs/react-redux/tree/master/docs
Provider自定义组件：
Makes the Redux store available to the connect() calls in the component hierarchy below。
这个Provider组件使得它内部的自定义组件可以使用connect()函数。
Normally, you can’t use connect() without wrapping a parent or ancestor component in <Provider>
通常的，你不能在没有Provider父亲或者组件的情况下，使用connect()函数。
属性store (Redux Store): APP中唯一的那个store
```jsx harmony
import React, { PropTypes } from 'react'
import { bindActionCreators } from 'redux'
import { connect } from 'react-redux'
import Header from '../components/Header'
import MainSection from '../components/MainSection'
import * as TodoActions from '../actions'
const App = ({ todos , actions }) => (
  <div>
    {JSON.stringify(todos)}
    <Header addTodo={actions.addTodo} />
    <MainSection todos={todos} actions={actions} />
  </div>
)
App.propTypes = {
  todos: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
}
const mapStateToProps = state => ({
  todos: state.todos
})
const mapDispatchToProps = dispatch => ({
    actions: bindActionCreators(TodoActions, dispatch)
})
export default connect(
  mapStateToProps,
  mapDispatchToProps
)(App)
```
