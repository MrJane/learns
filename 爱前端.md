### JS进阶
#### 事件对象
##### 1.1 事件对象是什么
我们可以把事件的处理函数，当做一个回调函数。`click`事件发生的时候，才调用这个`function(){}`
```javascript
oDiv.onclick = function(){
}
```
`浏览器在调用这个事件处理函数，调用的时候还传进去一个实际参数`，这个参数是一个对象，表示这次点击事件的所有细节。比如按的什么按钮、点击的位置等等。
所以，我们的事件处理函数，就要通过一个形式参数来接收。
```javascript
oDiv.onclick = function(event){

}
```
比如，获得鼠标当前的位置：
```javascript
document.onmousemove = function(event){
	h1.innerHTML = "当前鼠标坐标为" + event.clientX + "," + event.clientY;
}
```
event.clientX表示触发事件的时候，鼠标的x位置（相对于视口）
不同的事件，就有不同的event值。可以想象到键盘事件，没有鼠标的位置。而是有event.keyCode按下去的键盘码的值。
##### 1.2 IE6、7、8的兼容问题
- 超级兼容大坑：在调用事件处理函数的时候，高级浏览器是传给这个事件处理函数一个实际参数event对象。但是IE6、7、8是给window对象绑定一个当前的event属性。
IE中：
```javascript
document.onmousemove  = function(){
	h1.innerHTML = "当前鼠标坐标为" + window.event.clientX + "," + window.event.clientY;
}
```
所以现在就有一个兼容性的处理的小窍门：
```javascript
//在页面上鼠标移动的时候，触发事件
document.onmousemove  = function(event){
	event = event || window.event;
	h1.innerHTML = "当前鼠标坐标为" + event.clientX + "," + event.clientY;
}
```
|| 就是或逻辑短路运算符，如果event有定义，那么就event对象；否则就是window.event对象。
IE中有很多方法的名字和高级浏览器不一样，比如昨天说的阻止默认事件：
```javascript
event.preventDefault();
```
在IE中是一个属性：
```javascript
event.returnValue = false;
```
这些的兼容性问题，就用能力检测来解决：
```javascript
//阻止默认的滚动事件，阻止的方法有浏览器兼容问题：
if(event.preventDefault){
	event.preventDefault();
}else{
	event.returnValue = false;
}
```
包括preventDefault()方法在IE6、7、8中不支持在内，我们要记住这三个：
```javascript
event.preventDefault()不兼容！ 在IE6、7、8中用event.returnValue=false; 代替
event.stopPropagation()不兼容！在IE6、7、8中用event.cancelBubble=true; 代替 
event.target不兼容，在IE6、7、8中用event.srcElement代替
```
event.target兼容解决，就是用一个短路语法
```javascript
var targetElem = event.target || event.srcElement;
```
#### 各种值
##### 2.1 鼠标位置event.clientX、event.screenX
下面4个值是全线兼容的：
```javascript
1event.clientX
2event.clientY
3event.screenX
event.screenY
```
这四个值都没有单位。
clientX表示鼠标距离视口左边x值
screenX表示鼠标距离整个屏幕左边x值
#### 滚轮事件
滚轮就是鼠标上的滚轮，它滚动的时候触发事件。
注意，window.onscroll这是窗口的卷动事件，不管因为什么（滚轮、滚动条、键盘上下键）导致页面卷动了，就会触发window.onscroll事件。
滚轮事件就是鼠标滚动的时候触发，不一定引起页面的卷动。
```javascript
1oDiv.onmousewheel = function(event){
2	oDiv.innerHTML = event.wheelDelta;
}
```
onmousewheel就是鼠标滚动事件，mouse鼠标，wheel就是轮子。
event参数最最重要的事就event.wheelDelta属性，表示滚动的方向。这是浏览器的规定：
如果滚动快速，可能出现120的整数倍，正负性是一样的。
onmousewheel事件的触发，是滚轮滚动一“咯噔”触发一次。
#### 滚屏原理
我们现在用原生JS讲解原理，页面上动画、尤其是动画序列、delay进场用jQuery来做更合适。

火车法：
HTML布局：
```html
1<div class="contanier">
2		<div class="page page0"><h1>0</h1></div>
3		<div class="page page1"><h1>1</h1></div>
4		<div class="page page2"><h1>2</h1></div>
5		<div class="page page3"><h1>3</h1></div>
6		<div class="page page4"><h1>4</h1></div>
	</div>
```
CSS从小到大都是height:100%; 撑高为浏览器屏幕高度
```css
html,body{
		width: 100%;
		height: 100%;
		overflow: hidden;
	}
	.contanier{
		width: 100%;
    	height: 100%;
		position: absolute;
		top: -300%;
		left: 0;
	}
	.page{
		width: 100%;
		height: 100%;
		background: yellowgreen;
		}
```
#### object类型
##### 1.1 对象的创建
创建一个对象，有两种方法，第一种比较简单，叫做字面量；第二种是用new Object()。
1.1.1 字面量的创建方式
````javascript
var obj = {
      name : "考拉",
      age : 18,
      sex : "男"
    };
	console.log(obj);
	console.log(obj.name);
	console.log(typeof obj);
````
{}就是对象的界定符，就是对象的字面量。对象有属性，所谓的属性就是这个对象的特点、特性，name、age、sex都是这个obj对象的属性（preperty）。
哲学上讲，什么是对象？对象就是属性的无序集合。
我们可以用.点语法、方括号法来获得一个对象的属性。那么你会发现，和数组有点相似，只不过数组的下标只能是数字0、1、2……，而我们的对象，可以用任何的词儿来当做属性名。

公式：
```javascript
{
	k : v,
	k : v,
	k : v,
	k : v
}
```
JSON和对象字面量的区别：
之前学习过JSON，JSON要求所有的k必须加引号，而对象字面量不需要加引号，当然加引号也不错。
JSON = JavaScript Object Notation，JS对象表示法。JSON是一个用于交换的格式，所以JSON不仅仅JavaScript用，后台语言比如PHP、Java、ASP等等都要识别JSON，为了最大的兼容，k必须加引号。也就是说，JSON里面的k加引号，不是因为JS，而是因为后台的那些语言。
JSON要比对象字面量，要严格，严格在哪儿呢？就是所有的k，必须加引号。
JSON：
```json
{
	"k" : v,
	"k" : v,
	"k" : v,
	"k" : v
} 
```
但是，下面的特殊情况，这个k必须加引号：
k是特殊字符
k是数字
k是有空格
k是关键字、保留字
先说一下，上面这些情况，也同时不能使用点语法来访问属性了，比如使用方括号：
```javascript
var obj = {
	name : "考拉"
};
console.log(obj["name"]);
```
特殊形式的k，必须要加上引号，检索属性的时候，必须用方括号：
```javascript
var obj = {
"24&*$&#@@)@!" : "哈哈",
"all name" : "考拉",
"++++%%%%" : "嘻嘻",
"var" : "么么哒",
"function" : "嘻嘻"
} 
	console.log(obj["24&*$&#@@)@!"]);
	console.log(obj["all name"]);
	console.log(obj["++++%%%%"]);
	console.log(obj["var"]);
	console.log(obj["function"]);
```
你会发现，JS会一个对象的属性名，没有特殊的规定。这是因为属性名不是标识符，没有那些规定。
对象的属性的访问，点语法是有局限的，它不能访问上面的特殊的那些情况。也不能访问以变量保存的k：
```javascript
var obj = {
		name : "考拉",
		age : 18,
		sex : "男",
		"study score" : 100
	}

	//console.log(obj."study score");//错误的
	console.log(obj["study score"]);	//正确的
	console.log(obj["a" + "ge"]);		//正确的
	var a = "sex";
	console.log(obj[a]);			//正确的
```
1.1.2 new Object()创建对象
```javascript
var obj = new Object();	//这是一个空对象，里面没有任何属性
obj.name = "考拉";
obj.age = 18;
obj.sex = "男";
console.log(obj);	
console.log(obj.age);	
console.log(typeof obj);
```
new是一个运算符，你没有看错，和+-*/一样是一个运算符。表示新创建一个对象。一会儿我们学习构造函数，实际上你将了解到new是一个函数调用的方式。Object()大写字母O，这是一个系统内置的构造函数，什么是构造函数，我们稍后讲到。
下面就可以用obj.k = v ;来追加属性了
```javascript
obj.name = "考拉";
```
这是一条语句，如同：
```javascript
oDiv.className = "current";
```
事实上，工程师更喜欢用字面量的方式来创建对象。因为更直观：
字面量方式：
```javascript
var obj = {
	name : "考拉",
	age : 18,
	sex : "男"
};
```
构造函数方式：
```javascript
var obj = new Object();
obj.name = "考拉";
obj.age = 18;
obj.sex = "男";
```
上面两种方式创建出来的对象，是相同的。字面量的方式直观、简单、并且有“封装”的感觉。所以我们鼓励大家用字面量来创建对象。
但是，不要杂糅：
```javascript
var obj = {};   //的确能创建一个空对象
obj.name = "考拉";   //追加属性
obj.age = 18;        //追加属性
obj.sex = "男";      //追加属性
```
##### 1.2 对象的属性值
对象属性值，可以是任何东西。比如数字、字符串、布尔值、正则表达式、对象、数组、函数……
```javascript
var kaola = {
		name : "考拉",
		age : 18,
		peiou : {
			name : "母考拉",
			age : 19
		}
	}

		console.log(kaola.peiou.age);
```
```javascript
var obj = {
		a : 1,
		b : "哈哈",
		c : true,
		d : /[A-Z]/g,
		e : function(){
			alert(1+2);
		},
		f : {
			p : 1
		}
		}
```
特别的，当对象的属性的值是一个函数的时候，我们称这个函数是对象的方法。
#### 二、对象的方法
当一个对象的属性的值，是一个函数，那么这个函数我们就称为对象的“方法”(method)。
方法就是一个对象能够做的事情，一般来说，就是一个动词。比如小明打招呼、长大、变性方法。
```javascript
var xiaoming = {
		name : "小明",
		age : 18,
		sex : "男",
		sayHello : function(){
			alert("你好，我是" + this.name);
			alert("今年" + this.age + "岁了");
			alert("我是可爱的小" + this.sex + "生");
			}
	}
	xiaoming.sayHello();
```
比如上面的案例，sayHello就是一个属性，只不过它的值是一个函数，所以我们就可以说xiaoming这个对象，有sayHello方法。
一个对象，方法函数里面的this指的是这个对象。

那我们复习一下现在，我们调用函数的方式有哪些？这些调用函数的方式，里面的this又是谁？
直接用()运算符来调用函数，那么函数里面的this指的是window对象
● 函数如果绑定给了某个HTML元素的事件上，那么函数里面的this就是这个HTML对象
● 用定时器调用函数，函数内部的this就是window对象
● 用对象打点（方法）来调用函数，函数里面的this指的是这个对象
● 用apply、call，可以人工设置this是谁了，百变。
说白了，我们学习“方法”，无非就是学习了一种函数的调用方式。这个函数里面的this指的是这个对象。
函数里面的this到底是谁，在函数定义的时候并不知道，要看函数如何被调用。

对象的方法的哲学，就是操作自己的属性。如果一个对象的方法，不操作自己的属性，那干嘛还要是方法呢？
zhangda方法，就是让自己的age++：
```javascript
var xiaoming = {
  name : "小明",
  age : 18,
  sex : "男",
  sayHello : function(){
  alert("你好，我是" + this.name);
  alert("今年" + this.age + "岁了");
  alert("我是可爱的小" + this.sex + "生");
  },
  zhangda : function(){
	this.age++;
  }
}
```
#### 构造函数
JavaScript规定，一个函数可以用new关键字来调用。那么此时将按顺序发生四件事情：
1）隐秘的创建一个新的空对象
2）将这个函数里面的this绑定到刚才创建隐秘新对象上
3）执行函数体里面的语句
4）返回这个新的对象
```javascript
function People(){
  this.name = "小明";
  this.age = 18;
  this.sex = "男";	
}
var xiaoming = new People();

console.log(xiaoming);
console.log(xiaoming.age);
console.log(typeof xiaoming);
```
上面的函数的机理：
好了，也就是说，我们现在学习了函数的新的调用方式：使用new关键字来调用。
此时很有意思，函数不仅仅能够执行，还能返回出来一个对象。也就是说，对象是函数“生”出来的，对象是函数“new”出来的。
我们称呼这个函数，叫做构造函数，一般的，构造函数用大写字母开头。也叫作People“类”。
我们称呼xiaoming这个对象是People类的实例。
#### 原型prototype
##### 4.1 原型的定义
我们先来看一个事儿：
```javascript
function fun(){
			alert("你好");
		}
	console.log(fun.prototype); //=>Objec{}
console.log(typeof fun.prototype); //=> object
```
在JavaScript中，任何一个函数，都有一个prototype属性，指向一个对象。我们输出了一个函数的prototype属性，你会发现是一个空对象。输出这个prototype的类型，发现是object类型。
prototype就是英语“原型”的意思。每个函数都有原型，原型是一个对象。
一个函数的原型，对于普通函数来说，没任何鸟用。但是如果函数是一个构造函数，那么函数的原型，用处极大！
```javascript
//构造函数，构造函数里面没有任何语句，也就是说，这个构造函数在执行的时候，不会给创建出来的对象添加任何属性。
function People(){

}
//构造函数的原型，我们更改了构造函数的原型，为一个新的对象：
People.prototype = {
	name : "考拉",
	sex : "男",
	age : 18
}

//当一个对象被new出来的时候，不仅仅执行了构造函数里面的语句，也会把这个函数的__proto__指向构造函数的prototype。
var xiaoming = new People();

console.log(xiaoming.__proto__);
console.log(xiaoming.__proto__ == People.prototype);

//当我们试图访问name、sex、age属性的时候，身上没有。那么就去查找原型，原型身上有，就当做了自己的属性返回了。
console.log(xiaoming.name);
console.log(xiaoming.sex);
console.log(xiaoming.age);
```
prototype一定是函数的属性！当这个函数是一个构造函数的时候，那么它new出来的对象，将以它的原型那个对象为new出来的实例的原型对象。
注意，任何一个对象，都有__proto__属性，这个属性是Chrome自己的属性，别的浏览器不兼容，但是别的浏览器也有原型对象，只不过不能通过__proto__进行访问而已。
这是属性指向自己的原型对象。

我们的JavaScript有一个非常牛逼的机制：原型链查找。
当我们试图访问一个对象身上的属性的时候，如果这个对象身上有这个属性，则返回它的值。如果它身上没有这个属性，那么将访问它的原型对象，检测它的原型对象身上是否有这个值，如果有返回它原型对象身上的这个值。

也就是说，我们刚才讲解了2个对象和一个函数的故事。任何一个函数都有原型，原型是一个对象，用prototype来访问。当这个函数是构造函数的时候，new出来的对象，它们的原型对象就是这个构造函数的原型。
prototype我们称为“原型”，只有函数有原型
__proto__我们称为“原型对象”，任何对象都有原型对象。
##### 4.2 原型的用途
我们定义一个方法的时候，如果写在构造函数里面：
```javascript
function People(name,age){
			this.name = name;
		this.age = age;
		this.sayHello = function(){
			alert("你好,我是" + this.name + "我今年" + this.age + "岁了");
		}
	}

	var xiaoming = new People("小明",12);
	var xiaohong = new People("小红",11);

	xiaoming.sayHello();
	xiaohong.sayHello();
```
实际上这个函数被复制了两
````javascript
alert(xiaoming.sayHello == xiaohong.sayHello); //false
````
xiaoming身上的函数，和xiaohong身上的函数，不是同一个函数。
那应该怎么办呢？一句话：所有的属性要绑在对象身上，而所有的方法，定义在对象的原型对象中：
```javascript
function People(name,age){
//构造函数里面，负责定义一些属性，随着构造函数的执行，这些属性将绑定到new出来的对象身上
	this.name = name;
	this.age = age;
}
//把所有的方法，定义在原型对象身上：
People.prototype.sayHello = function(){
	alert("你好,我是" + this.name + "我今年" + this.age + "岁了");
}
```
```javascript
alert(xiaoming.sayHello == xiaohong.sayHello); //true
```
证明了xiaoming的sayHello方法和xiaohong的，是同一个函数。内存消耗小很多。
##### 4.3 JavaScript原型链机制
先学一个属性，constructor，函数的原生有constructor属性，指向构造函数。
```javascript
People.prototype.constructor //指向构造函数
```
我们之前说过，一个对象的原型身上有什么，那么实例对象就也可以打点调用什么，所以：
```javascript
xiaoming.constructor   //指向构造函数
```
只要是对象，一定有原型对象，就是说只要这个东西是个对象，那么一定有__proto__属性。
世界上只有一个对象没有原型对象，这个对象就是Object.prototype。

Object是一个函数，是系统内置的构造函数，用于创造对象的。Object.prototype是所有对象的原型链终点。
所以，当我们在一个对象上打点调用某个方法的时候，系统会沿着原型链去寻找它的定义，一直找到Object.prototype。

所有的引用类型值，都有内置构造函数。比如
new Object()
new Array()
new Function()
new RegExp()
new Date()

我们来看看数组的情况：

函数也是对象。JavaScript中函数是一等公民，函数是对象。函数也是对象，只不过自己能()执行。

基本类型值，也有包装类型。所谓包装类型，就是它的构造函数。
new Number()
new String()
new Boolean()

所以你就能明白，为毛毛”abc”能够调用indexOf()方法，是因为String.prototype身上有这个方法。

更多的理论：继承、in操作符、hasOwnPreperty、delete明天讲。理论和实际结合起来。
#### 五、面向对象的思维方式
实际上，在JS中面向对象技术，已经变为了组织代码的方式。
比如页面上有一个轮播图，就一个，我们用jQuery嗷嗷写就行了。但是页面上有三个轮播图，代码维护、共用的困难。所以就用面向对象来组织代码，这就是组件开发。
为了让大家体会面向对象的好处，或者说必须用面向对象的思路来解决问题，我们用游戏来引导你。
#### 继承

“人”类 ， “小学生”类。 小学生也是人，只不过“丰富了”人。
“人”类有的属性，“小学生”都有，比如姓名、年龄、性别。
“人”类有的方法，“小学生”都有，比如打招呼、吃饭、睡觉。
除此之外，
“小学生”还丰富了一些属性：学号、班级、小红花个数、是否少先队员
“小学生”还丰富了一些方法：学习、lol、上课

小学生类，继承了人类。一说继承，千万不要想到人生的遗产继承，感觉小学生比人类少，是人类的局部。千万不要这么想。在计算机世界中，继承是“丰富”，是比原来的类要多东西。
小学生继承于人类， 小学生更丰富。

说白了，People、Student两个类，Student类的实例，拥有 People的全部属性属性、方法。
现在，你就应该朦朦胧胧的感觉到，用原型链来实现。JavaScript中没有extends。
People叫做父类、超类； Student叫做子类。

JS中实现继承的口号：

子类的prototype等于父亲的某个实例


来看一个具体案例：
```javascript
 function People(name,age,sex){
			this.name = name;
			this.age = age;
		this.sex = sex;
		}
	People.prototype.sayHello = function(){
			alert("你好我是人" + this.name);
		}
	People.prototype.chifan = function(){
		alert("我吃饭了！mia mia");
		}


		function Student(name,age,sex,xuehao,xiaohonghuageshu){
			this.name = name;
		this.age = age;
		this.sex = sex;
			this.xuehao = xuehao;
		this.xiaohonghuageshu = xiaohonghuageshu;
		}
		//核心语句，继承的实现全靠这条语句了：
		Student.prototype = new People();
		
		Student.prototype.sayHello = function(){
			alert("你好我是小学生，我的学号是" + this.xuehao);
		}
		Student.prototype.study = function(){
			alert("好好学习，天天向上");
		}
		Student.prototype.lol = function(){
			alert("玩儿英雄联盟啊！");
		}

		var xiaohong = new Student("小红",11,"女",20160001,4);
		//xiaohong.lol();
		//xiaohong.chifan();
		xiaohong.sayHello();
```
子类可以覆盖父类的一些方法，父类的方法不冲突，因为我们子类追加的方法，追加到了父类的实例上。
这种方法不行：追加子类方法的时候，父类也被改了：
#### 三、对象与属性
##### 3.1 in运算符
返回一个布尔值，表示这个属性是不是对象的属性。
```javascript
var obj = {
			a : 1,
			b : 2,
			c : false
		}

		console.log("a" in obj);	//true
		console.log("b" in obj);	//true
		console.log("c" in obj);	//true
		console.log("d" in obj);	//false
```
in不仅仅检测是对象自己有没有这个属性，如果原型链上有这个属性，那么也会返回true。整个原型链如果没有这个属性，就返回false。也就是说，in操作符会进行原型链查找。
for in 这个循环，会把原型链上所有的可枚举的属性列出来：
```javascript
for(var k in obj){
	console.log(k);
}
```
什么是可枚举，系统默认的属性（比如constructor）都是不可枚举的。for in循环能够把自己添加的属性罗列出来，罗列的不仅仅是自己身上的属性，还有原型链上的所有属性。
##### 3.2 hasOwnProperty方法
这个方法定义在了Object.prototype对象上面，所以任何一个Object都能够拥有这个方法。
这个方法返回true、false。表示自己是否拥有这个属性，不考虑原型链。就看自己身上有没有这个属性，不进行原型链查找
```javascript
var obj = {
			a : 1,
			b : 2,
			c : 3
		}
		obj.__proto__ = {
			d : 4
		}

		console.log(obj.hasOwnProperty("a")); //t
		console.log(obj.hasOwnProperty("b")); //t
		console.log(obj.hasOwnProperty("c")); //t
		console.log(obj.hasOwnProperty("d")); //f
```
for……in考虑原型链，所以我们可以内嵌一个判断，把自己身上的属性输出：
```javascript
for(var k in obj){
	obj.hasOwnProperty(k) && console.log(k);
}
```
##### 3.3 对象直接打点验证某个属性是否存在
对象打点调用属性，我们之前的课程已经讲过，遍历原型链。所以就可以看出来属性是否在自己身上、原型链上。如果在，就返回值；如果不在就返回undefined.
```javascript
var obj = {
			a : 1,
			b : 2,
			c : 3
		}
		obj.__proto__ = {
			d : 4
		}
		console.log(obj.m);	//undefined
 		console.log(obj.a);	//1
		console.log(obj.b);	//2
 		console.log(obj.c);	//3
 		console.log(obj.d);	//4
```
有个误会，比如obj.m值就是undefined，那么obj.m还是返回undefined。不知道m属性存在不存在。
#### 四、instanceof运算符
类在英语里面叫做class，实例在英语里面叫做instance。
instaceof运算符：
```javascript
A instaceof B//验证A对象是不是B类的实例。
```
比如：
```javascript
//类，构造函数
		function Dog(){

		}
		//实例化一个对象
		var d = new Dog();
		//验证d是不是Dog的一个实例
		console.log(d instanceof Dog);//true
```
这里要注意一个事儿：“HelloKitty是狗”：
```javascript
//类，构造函数
		function Dog(){

		}
	
		function Cat(){

		}
		Cat.prototype = new Dog();	//继承
		var hellokitty = new Cat();	//通过cat来实例一个
		console.log(hellokitty.constructor); //Dog
		console.log(hellokitty instanceof Cat); //true
		console.log(hellokitty instanceof Dog); //true
```
instanceof 运算符的机理： 遍访hellokitty这个对象的原型链上的每个原型对象，如果遍访到这个原型对象，是某个构造函数的prototype，那么就认为hellokitty是这个构造函数的实例，返回true。

一个数组用typeof检测的时候，返回object
```javascript
var arr = [];
console.log(typeof arr);//object
```
正则表达式也是：
```javascript
var obj2 = /ABC/g;
console.log(typeof obj2);
```
用instanceof运算符能够轻松解决数组的识别：
```javascript
var arr = [];
console.log(arr instanceof Array);//true
```
ECMAScript5标准中新增了一个API验证数组：
```javascript
Array.isArray(arr)//true 
//IE9开始兼容。
```
总结一下，A instanceof B， 不能证明A是new B()出来的，因为可能是继承。
#### JavaScript代码的组织
JS代码放到哪里？
##### 1.1 外链JS文件
外链JavaScript是一个组织JS的非常好的方法。
```html
<script type="text/javascript" src="js/1.js"></script>
<script type="text/javascript" src="js/2.js"></script>
```
JS的执行顺序，就是引包顺序的先后顺序。`包不能隔开作用域的`：
a能够正常输出100。JS文件（JS包)是不能隔开作用域的。在JavaScript中，唯一能够隔开作用域的就是function。

JS包里面定义的变量、函数，将在HTML外部失去变量声明的提升、函数声明头的提升。 
本质上，写在不同的<script></script>标签对儿里面的变量、函数，就已经失去变量声明的提升、函数声明头的提升。
正因为如此，我们必须：
```html
<script type="text/javascript" src="1.js"></script>   → 这个包里面定义了函数fun
<script type="text/javascript">
fun();   //→ 执行fun的时候，浏览器已经认识了fun
</script>
```
##### 1.2 页面中的JS与HTML
页面上会出现很多很多的特效，那么此时JS的摆放的位置，应该放到HTML结构的后面，并且习惯上紧跟HTML结构。这样做的好处是，我们就知道每个JavaScript的含义了，就知道这个JavaScript是负责上面HTML特效的。
##### 1.3 window.onload
延迟加载，当页面中的所有元素加载完毕之后，触发这个事件。你要注意，什么叫所有元素加载完毕呢？页面上的img图片，都是一点一点通过HTTP传输过来，当所有的img都传输完毕之后，才触发window.onload事件。
所以，之前讲过chrome有个小问题，就是一个盒子如果是用img撑宽的，那么oDiv.clientWidth就是0。这是因为读取这个盒子的宽度的时候，这个img还没有加载完毕。解决方法就是写在window.onload里面：
```javascript
window.onload = function(){
	var box = document.getElementsByTagName("div")[0];
	alert(box.clientWidth);
}
```
之前说过，DOM0级添加的事件，不能出现同名的。
```javascript
oDiv.onclick = function(){}
oDiv.onclick = function(){}
```
以后出现的为准，所以页面上只能有一个window.onload。
但是，如果使用DOM2级，
```javascript
window.addEventListener(”load”,function(){},false);
window.addEventListener(”load”,function(){},false);
```
就能够添加多个window.onload事件的处理函数。依次执行（attachEvent里面是反着的）。
jQuery中对应的事件叫做：
```javascript
$(document).ready(function(){

});
```
jQuery中的所有事件，都是通过DOM2级的机制添加的，所以jQuery中所有的事件，都能够同名。下午再说。

window.onload在工作中是不允许使用的。因为这个会把JS提前，与自己的HTML结构分开了，所以还是应该一个结构、一个JS文件；一个结构、一个JS文件这么写。
但是，window.onload在应对几个东西的时候，有非常大的作用：
1） 表单验证
2） onscroll事件
3） ……
所有的刚性的、事关穿不穿帮、事关安全的，都要写在window.onload里面。
我们先学习一下表单事件，onsubmit事件表示表单试图提交的那个瞬间。这个事件只能加给form对象。当标签里面的submit按钮点击的时候，触发。
```javascript
//当表单提交的时候
form.onsubmit = function(){
	alert("哈哈啊，你要提交表单啦？我不让你提交");
	return false;   //onsubmit事件里面，如果写了return false就不能提交表单了
}
```
表单提交非常的“刚性”，事关网站的安全，所以一定一定要写在window.onload里面，不要单独写js文件，不要写在HTML结构后面。让浏览器第一时间知道form有一个onsubmit事件。
```javascript
window.onload = function(){
			var box = document.getElementsByTagName("div")[0];
			// 浏览器必须在第一时间知道，这个页面滚动条滚动，是有事件的。
			window.onmousewheel = function(event){
				event.preventDefault();
			}
		}
```
#### 二、外链JS文件策略
上午说了，一个js文件不是一个作用域，但是我们仍然希望一个js文件就是独立的作用域。所以，就需要把语句写在function里面。
没有任何的理由，将js文件里面的语句散着写，因为散着写作用域被污染的严重，多个效果会冲突。
必须把js里面的所有语句放到函数里面，有三种方法：
#### 2.1 js文件中IIFE，HTML不需要调用
把js文件中的所有语句放到IIFE中，就能够关注作用域。并且HTML文件中不用调用函数。
IIFE是个好东西，能够管理住作用域，函数的闭包能够保护函数的每个变量与别人不冲突
没毛病，有瑕疵，不方便二次使用这个函数。当页面上有两个轮播图的时候，同样的业务，必须要定义两次函数。而函数天生是要复用的，所以IIFE有缺陷。
##### 2.2 js文件中定义函数，在HTML页面上用()调用
这种调用函数的方式，就是用()来进行普通调用。没毛病，函数确实被复用了。
最近学过一种新的函数调用方式，就是用new来调用函数。实际上new就叫做组件开发
我们现在来稍微了解一下JS的垃圾回收机制，来看下面的语句：
````javascript
function fun(){
	var a = 1;
	a++;
	a*=9;
	alert(a);
}

fun();
````
当函数运行的时候，a变量将开辟一小块内存空间，存入1这个数字。然后数值发生变化，弹出数字18。然后js发现a变量没有被任何的定时器、事件监听“持有”，所以为了清理内存，JS就把a当做垃圾了。就回收了这个空间。

你看下面的语句：
````javascript
function fun(){
	var a = 1;
	document.onclick = function(){
		a++;
		alert(a);
	}
}

fun();
````
变量a被事件监听持有，所以fun虽然运行完毕了，但是浏览器不敢去清除a变量的空间。
所以每次点击页面，会弹出2、3、4、5、……。
##### 2.3 js文件中定义类，HTML中用new来调用函数
轮播图是new出来的。实际上就叫做组件开发。组件开发没别的，无非就是代码组织的一种方式。不学组件开发，页面也嗷嗷做，用函数风格， 也没啥问题，但是逼格不高。现在越来越流行把代码做成组件。
轮播图，与打气球、挡板球、贪吃蛇比，太简单了！
杂碎知识点：
写在prototype里面的函数，对象的实例是可以调用的。但是一些函数是内部函数，我们只希望函数自己调用自己。不希望实例来调用，习惯上写_开头命名。但是_不能阻止外部实例调用，没事儿，这就是一个约定。
```javascript
Slider.prototype._findMyElemsByClassName = function(className){

}
```
加上_的函数，说白了不向外暴露这个API。
 I’m so sorry，之前讲正则表达式没有说构造函数法和字面量法的区别。
字面量法，必须是正则表达式的字面量，用/  /来界定。里面不能有变量，不能有斩断链接。
但是，new RegExp()构造函数的语法：
```javascript
var reg = new RegExp(正则字符串,描述符字符串);
```
比如：
```javascript
var reg = new RegExp("^1[\d]{10}$","g");
```
好处就是可以用字符串的斩断链接，来拼接字符串，使用变量：
```javascript
var a = "kaola";
var reg = new RegExp("^" + a + "{1,2}$" , "g");
reg.test("woaikaolahahaha")
```
组件开发有一个天大的好处，就是不用依赖任何的框架。我们不需要使用jQuery，也不需要使用运动框架。
运动框架的哲学是什么？就是把任何的运动都封装：
```javascript
animate(oDiv,{"top":700,"left":700},100);
```
但是组件开发有一个思路，就是自己只管自己，不需要更多的复用。你想想看，传统轮播图中，能够运动的业务，就是left值。只涉及left值的改变，不涉及其他属性的改变，那为什么还要使用万能的运动框架呢？
组件的哲学和通用轮子不一样。通用轮子，要把所有浏览器、所有属性都要封装进来，注重复用、易用。组件开发只针对特定功能！！
当一个变量内部是一个setInterval、setTimeout的时候，那么这个变量被console.log输出的时候，变量的值是1。当定时器积累的时候，实际上值会变。不管怎么样，值正数。
这是一种非常简单的函数截流：
```javascript
if(this.timer){return;}
```
### React
#### React Webpack配置
##### webpack配置
引入babel-loader翻译js文件，但babel-loader依赖babel-core 所以webpack 要安装这两个包,还需要装babel-preset-es2015 //需要注意三个的版本差异
npm install babel-loader babel-core babel-preset-es2015 -D

配置react！安装react
npm install react -D  //为什么是开发依赖？为什么不用bower安装而是npm安装
1.react并不是在html里引入而是在js中import导入,所以npm安装都会node_modules文件夹里，import导入会自动寻找node_modules文件夹
2.


安装完依赖，webpack.config.js babel-loader中presets要增加一项react,
```json
{
                test:/\.js$/,
                exclude: /(node_modules|bower_components)/ ,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['es2015','react']
                    }
                }
            }
```
增加这项只之后又要安装一个```babel-preset-react```，不然```webpack```会报错


##### Hello组件
```jsx harmony
import React , {Component} from "react";

//我们定义一个叫做App的组件，在HTML中可以用<App></App>来使用它
//React要求自定义组件必须是大写字母开头！
//React要求自定义组件的类必须继承于React.Component类
class App extends Component{
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return <h1>我是React，很高兴遇见你！说{5000+5000}次我爱你！</h1>;
	}
}

//向外暴露
export default App;
```
使用Hello组件
```jsx harmony
import React from "react";
import {render} from "react-dom";
//引入组件
import App from "./App.js";

//使用、挂载组件，两个参数
//第一个参数是jsx语法
//第二个参数表示组件挂在哪里
render(
	<App></App> ,
	document.getElementById("app-container")
);

```

##### JSX语法：
jsx不能直接运行，是被babel-loader中的react这个preset翻译的
```javascript
{
     test:/\.js$/,
     exclude: /(node_modules|bower_components)/ ,
     use: {
     loader: 'babel-loader',
     options: {
          presets: ['es2015','react'] //
     }
           }
}
```
需要注意：
① 必须被一个单独的大标签包裹，比如div或者section
错误的：
```
return <h1>我是React，很高兴遇见你！HAHAHAHA</h1>
<h1>我是React，很高兴遇见你！HAHAHAHA</h1>;

```
正确的：应该被一个div包裹起来，小括号也挺好用的：
```
return (
	<div>
		<h1>我是React，很高兴遇见你！HAHAHAHA</h1>
		<h1>我是React，很高兴遇见你！HAHAHAHA</h1>
	</div>
);

```
② 标签必须封闭
错误的：
```jsx harmony
return (
	<div>
		<img src="" >
	</div>
);

```
正确的：
```
return (
	<div>
		<img src="" />
	</div>
);

```
③ class要写成className，for要写成htmlFor
错误的：
```
return (
	<div>
		<div class="box" ></div>
	</div>
);

```
正确的：
```
return (
	<div>
		<div className="box" ></div>
	</div>
);

```
④ HTML注释不能使用，只能使用JS注释。
```

```
⑤ 原生标签比如p、li、div如果要使用自定义属性，必须用data-前缀
错误：
```jsx harmony
return (
			<div>
				<h1>我是React，很高兴遇见你！</h1>
				<p a="10"></p>
			</div>
		);

```
正确：
```
return (
			<div>
				<h1>我是React，很高兴遇见你！</h1>
				<p data-a="10"></p>
			</div>
		);

```
如果是自定义标签，随便传属性：
```
<App a="123213"></App>
```
⑥ JS表达式用{}单大括号包裹，在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.
```
<h1>我是React，很高兴遇见你！{1+2}</h1>
{3 > 8 ? "A" : "B"}
```
⑦ 可以运行函数：
```jsx harmony
import React from "react";

//我们定义一个叫做App的组件，在HTML中可以用<App></App>来使用它
//React要求自定义组件必须是大写字母开头！
//React要求自定义组件的类必须继承于React.Component类
class App extends React.Component{

	//定义一个函数haha，接受一个参数
	haha(lanmu){
		if(lanmu == "篮球"){
			return (

					<ul>
			<li>乔丹</li>
						<li>科比</li>
						<li>奥尼尔</li>
					</ul>
			)
		}else if(lanmu == "足球"){
			return (
				<ul>
					<li>李铁</li>
					<li>郝海东</li>
					<li>C罗</li>
				</ul>
			)
		}
	}

	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return (
			<div>
				<h1>我是React，很高兴遇见你！</h1>

				<h3>JSX语法很好用哦！</h3>
				{3 > 8 ? "A" : "B"}

				<h3>JSX可以调用函数哦！</h3>
				{this.haha("足球")}
			</div>
		);
	}
}

//向外暴露
export default App;

```
⑧ 样式使用双大括号
```
<h3>JSX可以设置样式哦！</h3>
<div style={{"width":"100px","height":20 + 30 + "px","backgroundColor" : "red"}}></div>

```
⑨ 可以使用数组，数组中如果是JSX语法，数组会被自动展开。所以不需要使用ng-repeat这样的指令展开数组。


#### React中的数据传递
React中跟数据有关系的就三个东西：state、props、context。我们可以叫做数据传递三兄弟。
##### 组件自己身上的属性：
组件自己身上的属性值变化，不会引起视图改变
我们可以在组件的类定义里面写constructor构造器，里面定义this.a = 100 。表示给组件的实例绑定一个a属性，值是100。在jsx中使用的时候，直接this.a即可。
```jsx harmony
import React from "react";

class App extends React.Component{
	//构造函数
	constructor(){
		super();  //要求调用super
		this.a = 100;
	}
	add () {
            this.a++;
            console.log(this.a); //点击按钮的时候this.a确实变化了，但是视图没有更新，所以React中，组件自己的属性的变化不会引发视图的变化！！
    }
	//组件中最重要的方法就是render方法，render是渲染的意思
	render(){
		//返回一个jsx语法，非常牛逼语法
		return (
			<div>
				{this.a}
				<button onClick={this.add.bind(this)}>点我++</button>
			</div>
		);
	}
}
//向外暴露
export default App;
```
① 绑定监听使用onClick、onMousedown、onMouseenter、onBlur，把on后面的字母大写，React会自动识别React事件。
② 绑定监听函数的时候，this上下文是有问题的，所以需要使用bind()方法来设置上下文
③ 绑定监听函数的时候，注意用{}而不是""
```
错误的：
<input type="button" value="按我" onClick="(this.add).bind(this)" />
```
##### 4.2 闭包中的值变化，不会引起视图改变
```jsx harmony
import React from "react";

class App extends React.Component{
	render(){
		let b = 99; //这个b在render函数中相当于闭包
		return (
			<div>
				<p>{b}</p>
				<p>
					<input type="button" value="按我" onClick={()=>{b++;console.log(b) //点击按钮b值确实变化;}} />
				</p>
			</div>
		);
	}
}

//向外暴露
export default App;
//闭包中的值变化，也不会引起视图的改变！
```
##### 4.3 三兄弟之一 ：state
React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。
React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。
```jsx harmony
import React from "react";
class App extends React.Component{
 	constructor(){
 		super();
 		this.state = {
 			a : 100,
 			b : 200,
 			c : 300
 		}
 	}
 	add(){
 			this.setState({a : this.state.a + 1});
 	}
 	render(){
 		return (
 			<div>
 				<h1>我是APP组件</h1>
 				<p>我有状态state</p>
 				<p>a : {this.state.a}</p>
 				<p>b : {this.state.b}</p>
 				<p>c : {this.state.c}</p>
 				<p>
 					<input type="button" value="按我" onClick={(this.add).bind(this)}/>
 				</p>
 			</div>
 		)
 	}
}
//向外暴露
export default App;
```
只有更新三兄弟，才会引发Virtual DOM的改变，从而改变DOM。
定义state： 在构造函数中使用this.state属性即可
使用state ：在JSX中{this.state.a}
改变state： this.setState({a : this.state.a + 1});  不能写++，因为state属性值只读this.state.a++会改变本身
state是内部的（所以也叫作local state），只有组件自己能改变自己的state，别人想改变自己的state，都不可能！
后面要介绍Redux架构，所有组件自己的state越来越少用了，而是变为了Redux中的state，不要混淆
##### 4.4props
就是定义在自定义组件标签上面的值，就是props。当props改变的时候，会引发Virtual DOM的改变，从而引发视图的重绘。
react崇尚数据的单向流动，所以设计的时候就是让数据从父组件流向子组件。props在子组件中是只读的，不能修改的。
如果父组件App，想往子组件MyCompo中传值，使用属性：
```jsx harmony
app.js：
import React from "react";
import MyCompo from "./MyCompo.js";
class App extends React.Component{
 	constructor(){
 		super();
 	}
 	render(){
 		return (
 			<div>
 				<MyCompo a="66" b="77" c="88"></MyCompo>
 			</div>
 		)
 	}
}
//向外暴露
export default App;

```
子组件MyCompo中就可以无脑使用this.props来枚举传入的属性：
```jsx harmony
MyCompo.js:
import React from "react";
class MyCompo extends React.Component{
 	constructor(){
 		super();
 	}
 	render(){
 		return (
 			<div>
 				我是MyCompo组件
 				<p>{this.props.a}</p>
 				<p>{this.props.b}</p>
 				<p>{this.props.c}</p>
 			</div>
 		);
 	}
}
//向外暴露
export default MyCompo;
```
如果需要在构造函数中使用这个值，此时系统会将props最为构造函数的第一个参数传入：
```jsx harmony
class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			c : props.c
 		}
 	}
 }
//在子组件中，props是只读的，不能修改props的值。如果要修改，用state来接收。
```
##### props是标签上的属性可以被验证有效性：
npm install --save-dev prop-types //react分离了
```jsx harmony
import React from "react";
import { PropTypes } from "prop-types";
class MyCompo extends React.Component{
 	constructor(props){
 		super();
 		this.state = {
 			c : props.c
 		}

 	}
 	//MyCompo.propTypes={}  //propTypes不能写在实例上，这是类的属性，只能在外面挂载
 	render(){
 		return (
 			<div>
 				我是MyCompo组件
 				<p>{this.props.a}</p>
 				<p>{this.props.b}</p>
 				<p>{this.state.c}</p>
 				<p>
 					<input type="button" value="按我" onClick={()=>{this.setState({c : this.state.c + 1});}}/>
 				</p>
 			</div>
 		);
 	}
}
//定义组件需要传入的参数，这些都是语法规定
//类名.propTypes，值是一个JSON。key就是需要传进来的props属性名，v就是对它的限制,propTypes不能写在实例上
MyCompo.propTypes = {
	a : PropTypes.string.isRequired,  	//a属性是一个字符串，必传
	b : PropTypes.string,  				//b属性是一个字符串，不必传
	c : PropTypes.number.isRequired		//c属性是一个数组，必传
};
//向外暴露
export default MyCompo;
```
#### 子组件穿父组件
如果非要从下到上传输数据呢？子组件要把数据返回给父组件，此时只能用奇淫技巧。就是父组件传一个函数给子组件，
子组件通过传参数调用函数将数据返回给父组件的函数，父组件的函数接受实参改变父组件中的state等值。
父组件App现在想让子组件MyCompo设置App自己的state.d值，此时就需要传入d值，并且传入一个设置d值的函数到子组件：


#### 4.5 三兄弟之三： context
上下文的精髓是可以跨级传递数据，爷爷组件可以直接传递数据到孙子组件。
语法比较晦涩：

##### 五、其他API
###5.1 无状态组件
当我们现在的组件仅仅是为了呈递一些DOM元素，没有state、props等东西，此时可以不用费劲
class My extends React.Component{}
而是一个暴露简单函数即可：
```jsx harmony
//My.js
import React from "react";

export default () => {
	return (
		<div>
			<h1>我是My组件</h1>
		</div>
	)
}
```
此时真的可以用它：
```jsx harmony
import React from "react";
import My from "./My.js";

class App extends React.Component{
 	constructor(){
 		super();

 	}

 	render(){
 		return (
 			<div>
 				<My></My>
 			</div>
 		)
 	}
}

//向外暴露
export default App;
```
#### 5.2 默认属性
如果没有传入name输入，那么就以“菜鸟”作为属性：
```jsx harmony
	constructor(props){
		super(props);
    this.state = {
         name : props.name || "菜鸟"
        }
	}
	//现在很少用getDefaultProps了
```
####5.3 组件的生命周期
组件从没有诞生到诞生，到被移除的完整生命周期，都提供了可以触发事件的函数接口，就是生命周期。
组件的生命周期包含三个主要部分：

挂载： 组件被插入到DOM中。
更新： 组件被重新渲染，查明DOM是否应该刷新。
移除： 组件从DOM中移除。
```jsx harmony
//挂载之前
	componentWillMount(){
		console.log("componentWillMount");
	}

	//在挂载结束之后马上被调用。需要DOM节点的初始化操作应该放在这里。
	componentDidMount(){
		console.log("componentDidMount");
	}

 	//当组件做出是否要更新DOM的决定的时候被调用。“门神”，在改变状态的时候可以选择通过或者不通过。
 	shouldComponentUpdate(nextProps , nextState){
 		if(nextState.a > 0.8){
 			return true;
 		}
 		alert("本次没有随机到大于0.8的，更新被阻止");
 		return false;
 	}

 	//在更新发生之前被调用，没有把门的功能
 	componentWillUpdate(){
		console.log("componentWillUpdate");
 	}

 	//在组件移除和销毁之前被调用
 	componentWillUnmount(){
 		console.log("componentWillUnmount");
 	}

```
##### 5.4 React中的表单
React没有提供类似Angular中复杂的表单验证功能，也没有双向数据绑定！
如果非要做一个效果：文本框中输入内容，实时改变h1中的内容此时就要用模拟的方法，监听文本框的事件，然后改变组件的state状态。
```jsx harmony
import React from "react";
class My2 extends React.Component{
	constructor(props){
		super();
	 	this.change = (this.change).bind(this);
	 	this.state = {
	 		"txt" : ""
	 	}
	}
	change(event){
		this.setState({"txt" : event.target.value });
	}
	render(){
		return (
			<div>
			 	<input type="text" onInput={this.change} />
			 	<h1>{this.state.txt}</h1>
 			</div>
		)
	}
}
export default My2;
```
##### 5.5 ref DOM钩子

```jsx harmony
//有时候需要操作DOM元素，ref属性表示一个钩子。可以在其他地方使用this.refs来获得这个DOM元素。
import React from 'react';
class My3 extends React.Component{
    constructor (){
        super();
        this.handleChange =this.handleChange.bind(this);
    }
    handleChange(){
        this.refs.mybox.style.background='red';
        console.log(this.refs.mybox);
    }
    render(){
        return(
            <div>
                <input type="button" onClick={this.handleChange}/>
                <div ref="mybox" style={{width:'100px',height:'100px',backgroundColor:'orange'}}></div>
            </div>
        )
    }
}
export default My3;
```
#### Redux
Redux is a predictable state container for JavaScript apps.
Redux是一个可以预测状态的JS app容器。

通过例子来学习Redux：
下载https://github.com/reactjs/redux/
然后打开\examples\counter-vanilla

The whole state of your app is stored in an object tree inside a single store.
你的App中全部的state都被存储在一个单独的store中，形式是object tree。

The only way to change the state tree is to emit an action , an object describing what happened
唯一的更改state的途径就行emit一个action，这个action描述了发什么什么事。

To specify how the actions transform the state tree, you write pure reducers
为了指定这些actions如何改变state tree，你必须书写简单的、纯净的reducers。
#### 三、React-Redux
#### 3.1 不使用React-Redux遇见的灾难
刚才我们学习了Redux，已经基本知道Redux怎么玩儿了，大致步骤：
设置一个reducer，
弄一个store，从Redux.createStore(reducer);
弄一个render函数
注册一下render，store.subscibe(render)
写监听了，此时要记得store.dispatch(action)，不是直接改store。
此时和React还没有直接产生关系，换句话说在React中没有使用Redux技术
#### 我们现在看一下counter这个案例：
```jsx harmony
import React from 'react';
import ReactDom from 'react-dom';
import counter from './counter';
import Counter from './MyCounter'
import {createStore} from 'redux';
const rootEl = document.getElementById('root')
let store = createStore(counter);
const render = () => ReactDom.render(
    <Counter
        value={store.getState().n}
        increment ={()=>{store.dispatch({type:'INCREMENT'})}}
        decrement={()=>{store.dispatch({type:'DECREMENT'})}}
    ></Counter>,
    rootEl
);
render();
store.subscribe(render);
```
这个案例纯属霸王硬上弓，就是我们现在通过标签的属性，将store的值，和对store的操作传给了组件！这太二了！
```jsx harmony
const render = () => {ReactDOM.render(
  <Counter
	  value={store.getState()}
	  onIncrement={() => store.dispatch({ type: 'INCREMENT' })}
	  onDecrement={() => store.dispatch({ type: 'DECREMENT' })}
  />,
  rootEl
)};

```
那次此时灾难是什么？比如一个组件内部要多store有10种操作，你还传10个属性下去啊？再比如，组件内部还有组件要操作store，你还一直往下传啊？
所以我们使用一个粘合剂，要优雅的把react和redux合并起来，这个包就叫做react-redux。
react-redux可以让任何组件在任何地方看见store，机理实际上就是昨天学习的context。但是我们用的时候和context无关，人家帮我们写好了。
此时我们怎么学习react-redux，还是老方法，结合官方文档看官方demo。
我们要攻克todomvc这个官方demo。
#### 3.2 结合官方文档看官方demo(todomvc)
React-Redux给我们提供了两个东西：Provider组件、connect函数。
Provider组件要求是最大的组件，传入store属性，此时天下无人不识君。
官方文档：https://github.com/reactjs/react-redux/tree/master/docs
Provider自定义组件：
Makes the Redux store available to the connect() calls in the component hierarchy below。
这个Provider组件使得它内部的自定义组件可以使用connect()函数。
Normally, you can’t use connect() without wrapping a parent or ancestor component in <Provider>
通常的，你不能在没有Provider父亲或者组件的情况下，使用connect()函数。
属性store (Redux Store): APP中唯一的那个store
```jsx harmony
import React, { PropTypes } from 'react'
import { bindActionCreators } from 'redux'
import { connect } from 'react-redux'
import Header from '../components/Header'
import MainSection from '../components/MainSection'
import * as TodoActions from '../actions'
const App = ({ todos , actions }) => (
  <div>
    {JSON.stringify(todos)}
    <Header addTodo={actions.addTodo} />
    <MainSection todos={todos} actions={actions} />
  </div>
)
App.propTypes = {
  todos: PropTypes.array.isRequired,
  actions: PropTypes.object.isRequired
}
const mapStateToProps = state => ({
  todos: state.todos
})
const mapDispatchToProps = dispatch => ({
    actions: bindActionCreators(TodoActions, dispatch)
})
export default connect(
  mapStateToProps,
  mapDispatchToProps
)(App)
```
